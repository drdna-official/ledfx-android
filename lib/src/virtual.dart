import 'dart:async';
import 'dart:math';

import 'package:flutter/foundation.dart';
import 'package:ledfx/src/core.dart';
import 'package:ledfx/src/devices/device.dart' show Device;
import 'package:ledfx/src/effects/const.dart';
import 'package:ledfx/src/effects/effect.dart';
import 'package:ledfx/src/effects/utils.dart';
import 'package:ledfx/src/events.dart';
import 'package:nanoid/nanoid.dart';

enum TransitionMode { add }

class VirtualConfig {
  String name;
  String deviceID;
  bool autoGenerated;
  int minFreq;
  int maxFreq;
  String mapping;
  int? grouping;
  double maxBrightness;
  int centerOffset;
  bool previewOnly;
  double transitionTime;
  TransitionMode transitionMode;
  int rows;
  VirtualConfig({
    required this.name,
    required this.deviceID,
    required this.autoGenerated,
    this.minFreq = MIN_FREQ,
    this.maxFreq = MAX_FREQ,
    this.mapping = "span", // span | copy
    this.grouping,
    this.maxBrightness = 1.0,
    this.centerOffset = 1,
    this.previewOnly = false,
    this.transitionTime = 0.4,
    this.transitionMode = TransitionMode.add,
    this.rows = 1,
  });
}

class SegmentConfig {
  final String deviceID;
  final int start;
  final int end;
  final bool inverted;
  SegmentConfig(this.deviceID, this.start, this.end, this.inverted);
}

class Virtual {
  Virtual({required this.id, required this.config, required this.ledfx}) {
    fadeTimer = 0;
    freqRange = (config.minFreq, config.maxFreq);
  }
  final String id;
  final LEDFx ledfx;
  final VirtualConfig config;
  Map<String, dynamic> virtualConfig = {};
  String get name => config.name;
  String get deviceID => config.deviceID;
  bool get autoGenerated => config.autoGenerated;
  int get rows => config.rows;
  set rows(r) {
    config.rows = max(1, r);
  }

  bool _active = false;
  bool get active => _active;
  set active(param) {
    if (param && !_active) {
      activate();
    }
    if (!param && _active) {
      deactivate();
    }
    _active = param;
  }

  bool _paused = false;
  bool get paused => _paused;

  bool _streaming = false;
  bool get streaming => _streaming;

  Effect? _activeEffect;
  Effect? get activeEffect => _activeEffect;
  //
  // _outputThread
  // _transitionEffect

  // _minTime

  // multiplier to fade in(-)/out(+)
  late int fadeTimer;
  bool _calibration = false;

  bool _hlState = false;
  Device? _hlDevice;
  int _hlStart = 0;
  int _hlEnd = 0;
  int _hlStep = 1;

  bool _osActive = false;

  String? fallbackEffectType;
  bool fallbackActive = false;
  bool fallbackFire = false;
  String? fallbackConfig;
  Timer? fallbackTimer;
  bool fallbackSuppressTransition = false;

  late (int, int) freqRange;

  List<Device>? _cachedDevices;
  List<Device> get devices => () {
    if (_cachedDevices != null) return _cachedDevices!;
    final devs = <Device>[];
    for (var s in segments) {
      if (ledfx.devices.devices[s.deviceID] != null) {
        devs.add(ledfx.devices.devices[s.deviceID]!);
      }
    }
    _cachedDevices = devs;
    return _cachedDevices!;
  }();

  int? _cachedPixelCount;
  int get pixelCount => () {
    if (_cachedPixelCount != null) return _cachedPixelCount!;
    if (config.mapping == "span") {
      int total = 0;
      for (var s in segments) {
        total += (s.end - s.start + 1);
      }
      _cachedPixelCount = total;
    } else if (config.mapping == "copy") {
      if (segments.isNotEmpty) {
        _cachedPixelCount = segments.fold<int>(0, (p, s) {
          return max(p, (s.end - s.start + 1));
        });
      } else {
        _cachedPixelCount = 0;
      }
    } else {
      _cachedPixelCount = 0;
    }
    return _cachedPixelCount!;
  }();

  int? _cachedRefreshRate;
  int get refreshRate => () {
    if (_cachedRefreshRate != null) return _cachedRefreshRate!;
    if (devices.isEmpty) return 0;
    _cachedRefreshRate = devices.fold<int>(360, (p, d) {
      return min(p, d.maxRefreshRate);
    });
    return _cachedRefreshRate!;
  }();

  List<SegmentConfig> segments = [];
  //start, stop, step, segment_start, segment_end
  Map<String, List<(int, int, int, int, int)>>? _cachedSegmentByDevice;
  Map<String, List<(int, int, int, int, int)>> get segmentsByDevice => () {
    if (_cachedSegmentByDevice != null) return _cachedSegmentByDevice!;
    int dataStart = 0;
    final Map<String, List<(int, int, int, int, int)>> segmentsByDevice = {};
    for (var s in segments) {
      final segWidth = s.end - s.start + 1;
      int start, stop, step = 0;
      if (!s.inverted) {
        start = dataStart;
        stop = dataStart + segWidth;
        step = 1;
      } else {
        start = dataStart + segWidth - 1;
        stop = (dataStart == 0) ? 0 : dataStart - 1;
        step = -1;
      }

      final segmentInfo = (start, stop, step, s.start, s.end);
      if (segmentsByDevice.containsKey(s.deviceID)) {
        segmentsByDevice[s.deviceID]!.add(segmentInfo);
      } else {
        segmentsByDevice[s.deviceID] = [segmentInfo];
      }

      dataStart += segWidth;
    }
    _cachedSegmentByDevice = segmentsByDevice;
    return _cachedSegmentByDevice!;
  }();

  int? _cachedEffectivePixelCount;
  int get effectivePixelCount => () {
    if (_cachedEffectivePixelCount != null) return _cachedEffectivePixelCount!;
    _cachedEffectivePixelCount = _getEffectivePixelCount(pixelCount);
    return _cachedEffectivePixelCount!;
  }();

  int? _cachedGroupSize;
  int get groupSize => () {
    if (_cachedGroupSize != null) return _cachedGroupSize!;
    _cachedGroupSize = (config.grouping == null || config.grouping! < 1)
        ? 1
        : config.grouping;
    return _cachedGroupSize!;
  }();

  int _getEffectivePixelCount(int physicalPixelCount) {
    return (physicalPixelCount / groupSize).ceil();
  }

  final List _oneshots = [];
  List get oneshots => _oneshots;

  void del() {
    _active = false;
  }

  Timer? _frameTimer;
  double _frameInterval = 0.001; // Calculated sleep time
  double fpsToSleepInterval(int fps) => max(0.001, 1 / fps);
  void activate() {
    if (devices.isEmpty) {
      print("no devices setup");
      return;
    }
    if (activeEffect == null) {
      print("no effect configured");
      return;
    }

    print("Virtual $id: Activating with segments $segments");

    if (!_active) {
      _active = true;
      try {
        activateSegments(segments);
      } on ArgumentError catch (e) {
        print(e.toString());
      }
      _osActive = false; // Reset OS active flag
    }
    // Calculate the base interval needed for the desired FPS
    _frameInterval = fpsToSleepInterval(refreshRate);
    _frameTimer = Timer.periodic(
      Duration(milliseconds: (_frameInterval * 1000).round()),
      _virtualLoop,
    );
  }

  void deactivate() {
    _active = false;
    _frameTimer?.cancel();
    _frameTimer = null;
    _osActive = false;

    deactivateSegments();
    ledfx.events.fireEvent(VirtualPauseEvent(id));
    ledfx.virtuals.checkAndDeactivateDevices();
  }

  void _virtualLoop(Timer timer) {
    if (!_active) {
      timer.cancel();
      return;
    }

    // final startTime = DateTime.now().microsecondsSinceEpoch;

    if (fallbackFire) {
      setFallback();
      fallbackFire = false;
    }

    if (activeEffect != null &&
        activeEffect!.isActive &&
        activeEffect!.pixels != null) {
      _assembledFrame = assembleFrame();
      if (_assembledFrame != null && !paused) {
        if (!config.previewOnly) {
          flush();
        }
        fireUpdateEvent();
      }
    }

    // --- Frame Rate Adjustment (Replacing time.sleep) ---

    // 4. Calculate actual runtime and adjust for the next frame.
    // final double runTimeSeconds =
    //     (DateTime.now().microsecondsSinceEpoch - startTime) / 1000000.0;

    // // Calculate required sleep time
    // double sleepTimeSeconds = max(0.001, _frameInterval - runTimeSeconds);

    // If timing must be precise, cancel and reschedule the timer.
    /*
    timer.cancel();
    _frameTimer = Timer(Duration(milliseconds: (sleepTimeSeconds * 1000).round()), () {
        // Run the logic again
        _threadFunction(timer); 
    });
    */
  }

  void invalidateCache() {
    _cachedPixelCount = null;
    _cachedRefreshRate = null;
    _cachedDevices = null;
    _cachedSegmentByDevice = null;
    _cachedEffectivePixelCount = null;
    _cachedGroupSize = null;
  }

  void activateSegments(List<SegmentConfig> segments) {
    for (var config in segments) {
      final device = ledfx.devices.devices[config.deviceID];
      if (device == null) continue;
      if (!device.isActive) device.activate();
      device.addSegment(config);
    }
  }

  void deactivateSegments() {
    for (var device in devices) {
      device.clearVirtualSegments(id);
    }
  }

  void updateSegments(List<SegmentConfig> segments) {
    List<SegmentConfig> validatedSegments = [];
    for (var s in segments) {
      validatedSegments.add(validateSegment(s));
    }
    final _pixelCount = pixelCount;
    if (active) {
      deactivateSegments();
      try {
        activateSegments(validatedSegments);
      } catch (e) {
        deactivateSegments();
        activateSegments(this.segments);
        rethrow;
      }
    }

    this.segments = validatedSegments;
    invalidateCache();

    if (pixelCount != _pixelCount) {
      reactivateEffect();
    }

    virtualConfig["segments"] = segments;
    ledfx.virtuals.checkAndDeactivateDevices();
  }

  setFallback() {}
  clearFrame() {}
  void reactivateEffect() {}

  void flush([List<Float32List>? pixels]) {
    pixels = pixels ?? _assembledFrame;
    if (pixels == null) return;

    segmentsByDevice.forEach((deviceID, segments) {
      var data = <(List<Float32List>, int, int)>[];
      final device = ledfx.devices.devices[deviceID];
      if (device != null && device.isActive) {
        if (_calibration) {
          // renderCalibration(data, device, segments, deviceID);
        } else if (config.mapping == "span") {
          for (final (start, stop, step, devStart, devEnd) in segments) {
            final seg = getSlice(pixels!, start, stop, step);

            data.add((seg, devStart, devEnd));
          }
        } else if (config.mapping == "copy") {
          for (final (start, stop, step, devStart, devEnd) in segments) {
            final targetPhysicalLen = devEnd - devStart + 1;
            final targetEffectLen = _getEffectivePixelCount(targetPhysicalLen);
            var seg = getSlice(pixels!, start, stop, step);

            seg = effectiveToPhysicalPixels(seg, targetPhysicalLen);
            data.add((seg, devStart, devEnd));
          }
        }

        device.updatePixels(id, data);
      }
    });
  }

  void renderCalibration() {}

  List<Float32List>? _assembledFrame;
  List<Float32List>? assembleFrame() {
    activeEffect?.render();
    final frame = activeEffect?.getPixels();

    if (frame != null) {
      // clamp value
      for (final row in frame) {
        for (int j = 0; j < row.length; j++) {
          double value = row[j];
          row[j] = value.clamp(0.0, 255.0);
        }
      }

      return frame;
    }
    return null;
  }

  void fireUpdateEvent([List<Float32List>? frame]) {
    frame = frame ?? _assembledFrame;
    if (frame == null) return;

    ledfx.events.fireEvent(
      VirtualUpdateEvent(id, effectiveToPhysicalPixels(frame)),
    );
  }

  List<Float32List> effectiveToPhysicalPixels(
    List<Float32List> effectivePixels, [
    int? pixelCount,
  ]) {
    if (groupSize <= 1) return effectivePixels;
    pixelCount = pixelCount ?? this.pixelCount;

    effectivePixels = repeatAndTruncatePixels(
      effectivePixels,
      groupSize,
      pixelCount,
    );

    return effectivePixels;
  }

  SegmentConfig validateSegment(SegmentConfig segment) {
    final device = ledfx.devices.devices[segment.deviceID];
    if (device == null) {
      throw Exception("Invalid DeviceID - ${segment.deviceID}");
    } else if (segment.start < 0 ||
        segment.end < 0 ||
        segment.start > segment.end ||
        segment.start >= device.pixelCount ||
        segment.end >= device.pixelCount) {
      debugPrint(
        "Invalid segment pixels in Virtual '${config.name}': segment('${device.name}' (${segment.start}, ${segment.end})) valid pixels between (0, ${device.pixelCount - 1})",
      );

      int start = 0;
      int end = 0;
      if (segment.start < 0) start = 0;
      if (segment.end < 0) end = 0;
      if (segment.start > segment.end) start = end;
      if (segment.start >= device.pixelCount) start = device.pixelCount - 1;
      if (segment.end >= device.pixelCount) end = device.pixelCount - 1;

      return SegmentConfig(segment.deviceID, start, end, segment.inverted);
    }
    return segment;
  }

  void setEffect(Effect effect, [double? fallback]) {
    if (devices.isEmpty) {
      print("can not set effect, no active device");
    }

    if (fallback != null) {}

    _activeEffect = effect;
    _activeEffect!.activate(this);
    // TODO:
    // ledfx.events.fireEvent(EffectSetEvent);
    try {
      active = true;
    } catch (e) {
      active = false;
      print(e.toString());
    }
  }
}

class Virtuals with Iterable<MapEntry<String, Virtual>> {
  // Singleton instance
  static Virtuals? _instance;

  factory Virtuals({required LEDFx ledfx}) {
    _instance ??= Virtuals._(ledfx: ledfx);
    return _instance!;
  }

  Virtuals._({required this.ledfx}) {
    _paused = false;
    _virtuals = {};

    ledfx.events.addListener((e) {
      fireAllFallbacks();
      clearAllEffects();
    }, LEDFxEvent.CORE_SHUTDOWN);
  }

  final LEDFx ledfx;
  late bool _paused;
  late Map _virtuals;
  final Map<String, Virtual> virtuals = {};
  @override
  Iterator<MapEntry<String, Virtual>> get iterator => virtuals.entries.iterator;

  fireAllFallbacks() {
    virtuals.forEach((k, v) {
      v.setFallback();
    });
  }

  clearAllEffects() {
    virtuals.forEach((k, v) {
      v.clearFrame();
    });
  }

  Virtual createVirtual({String? id, required VirtualConfig config}) {
    id = id ?? nanoid(10);
    final v = Virtual(id: id, config: config, ledfx: ledfx);
    _virtuals[id] = v;
    return v;
  }

  destroyVirtual(String id) {
    if (!virtuals.keys.contains(id)) return;
    virtuals[id]!.del();
    virtuals.removeWhere((k, _) => k == id);
  }

  Virtual create(String id, VirtualConfig config) {
    final v = Virtual(id: id, config: config, ledfx: ledfx);
    _virtuals[id] = v;
    return v;
  }

  void pauseAll() {}

  void resetForCore(LEDFx ledfx) {}

  void checkAndDeactivateDevices() {}
}
