import 'dart:async';
import 'dart:math';

import 'package:flutter/foundation.dart';
import 'package:ledfx/src/core.dart';
import 'package:ledfx/src/devices/device.dart' show Device;
import 'package:ledfx/src/effects/const.dart';
import 'package:ledfx/src/events.dart';
import 'package:n_dimensional_array/domain/models/nd_array.dart';
import 'package:nanoid/nanoid.dart';

enum TransitionMode { add }

class VirtualConfig {
  String name;
  String deviceID;
  bool autoGenerated;
  int minFreq;
  int maxFreq;
  String mapping;
  int? grouping;
  double maxBrightness;
  int centerOffset;
  bool previewOnly;
  double transitionTime;
  TransitionMode transitionMode;
  int rows;
  VirtualConfig({
    required this.name,
    required this.deviceID,
    required this.autoGenerated,
    this.minFreq = MIN_FREQ,
    this.maxFreq = MAX_FREQ,
    this.mapping = "span", // span | copy
    this.grouping,
    this.maxBrightness = 1.0,
    this.centerOffset = 1,
    this.previewOnly = false,
    this.transitionTime = 0.4,
    this.transitionMode = TransitionMode.add,
    this.rows = 1,
  });
}

class SegmentConfig {
  final String deviceID;
  final int start;
  final int end;
  final bool inverted;
  SegmentConfig(this.deviceID, this.start, this.end, this.inverted);
}

class Virtual {
  Virtual({required this.id, required this.config, required this.ledfx}) {
    fadeTimer = 0;
    freqRange = (config.minFreq, config.maxFreq);
  }
  final String id;
  final LEDFx ledfx;
  final VirtualConfig config;
  Map<String, dynamic> virtualConfig = {};
  String get name => config.name;
  String get deviceID => config.deviceID;
  bool get autoGenerated => config.autoGenerated;
  int get rows => config.rows;
  set rows(r) {
    config.rows = max(1, r);
  }

  bool _active = false;
  bool get active => _active;
  set active(param) {
    if (param && !_active) {
      activate();
    }
    if (!param && _active) {
      deactivate();
    }
    _active = param;
  }

  bool _paused = false;
  bool get paused => _paused;

  bool _streaming = false;
  bool get streaming => _streaming;

  // _activeEffect _outputThread
  // _transitionEffect

  // _minTime

  // multiplier to fade in(-)/out(+)
  late int fadeTimer;
  bool _calibration = false;

  bool _hlState = false;
  Device? _hlDevice;
  int _hlStart = 0;
  int _hlEnd = 0;
  int _hlStep = 1;

  bool _osActive = false;

  String? fallbackEffectType;
  bool fallbackActive = false;
  bool fallbackFire = false;
  String? fallbackConfig;
  Timer? fallbackTimer;
  bool fallbackSuppressTransition = false;

  late (int, int) freqRange;

  List<Device>? _cachedDevices;
  List<Device> get devices => () {
    if (_cachedDevices != null) return _cachedDevices!;
    // return segments.map((seg)=> ledfx.devices.devices[seg.deviceID]).toList();
    final devs = <Device>[];
    for (var s in segments) {
      if (ledfx.devices.devices[s.deviceID] != null) {
        devs.add(ledfx.devices.devices[s.deviceID]!);
      }
    }
    _cachedDevices = devs;
    return _cachedDevices!;
  }();

  int? _cachedPixelCount;
  int get pixelCount => () {
    if (_cachedPixelCount != null) return _cachedPixelCount!;
    if (config.mapping == "span") {
      int total = 0;
      for (var s in segments) {
        total += (s.end - s.start + 1);
      }
      _cachedPixelCount = total;
    } else if (config.mapping == "copy") {
      if (segments.isNotEmpty) {
        _cachedPixelCount = segments.fold<int>(0, (p, s) {
          return max(p, (s.end - s.start + 1));
        });
      } else {
        _cachedPixelCount = 0;
      }
    } else {
      _cachedPixelCount = 0;
    }
    return _cachedPixelCount!;
  }();

  int? _cachedRefreshRate;
  int get refreshRate => () {
    if (_cachedRefreshRate != null) return _cachedRefreshRate!;
    if (devices.isEmpty) return 0;
    _cachedRefreshRate = devices.fold<int>(360, (p, d) {
      return min(p, d.maxRefreshRate);
    });
    return _cachedRefreshRate!;
  }();

  final List<SegmentConfig> segments = [];
  Map<String, List<(int, int, int, int, int)>>? _cachedSegmentByDevice;
  Map<String, List<(int, int, int, int, int)>> get segmentsByDevice => () {
    if (_cachedSegmentByDevice != null) return _cachedSegmentByDevice!;
    int dataStart = 0;
    final Map<String, List<(int, int, int, int, int)>> segmentsByDevice = {};
    for (var s in segments) {
      final segWidth = s.end - s.start + 1;
      int start, stop, step = 0;
      if (!s.inverted) {
        start = dataStart;
        stop = dataStart + segWidth;
        step = 1;
      } else {
        start = dataStart + segWidth - 1;
        stop = (dataStart == 0) ? 0 : dataStart - 1;
        step = -1;
      }

      final segmentInfo = (start, stop, step, s.start, s.end);
      if (segmentsByDevice.containsKey(s.deviceID)) {
        segmentsByDevice[s.deviceID]!.add(segmentInfo);
      } else {
        segmentsByDevice[s.deviceID] = [segmentInfo];
      }

      dataStart += segWidth;
    }
    _cachedSegmentByDevice = segmentsByDevice;
    return _cachedSegmentByDevice!;
  }();

  int? _cachedEffectivePixelCount;
  int get effectivePixelCount => () {
    if (_cachedEffectivePixelCount != null) return _cachedEffectivePixelCount!;
    _cachedEffectivePixelCount = _getEffectivePixelCount(pixelCount);
    return _cachedEffectivePixelCount!;
  }();

  int? _cachedGroupSize;
  int get groupSize => () {
    if (_cachedGroupSize != null) return _cachedGroupSize!;
    _cachedGroupSize = (config.grouping == null || config.grouping! < 1)
        ? 1
        : config.grouping;
    return _cachedGroupSize!;
  }();

  int _getEffectivePixelCount(int physicalPixelCount) {
    return (physicalPixelCount / groupSize).ceil();
  }

  final List _oneshots = [];
  List get oneshots => _oneshots;

  void del() {
    _active = false;
  }

  void activate() {}
  void deactivate() {
    _active = false;
    _osActive = false;
    deactivateSegments();
    ledfx.events.fireEvent(VirtualPauseEvent(id));
    ledfx.virtuals.checkAndDeactivateDevices();
  }

  void invalidateCache() {
    _cachedPixelCount = null;
    _cachedRefreshRate = null;
    _cachedDevices = null;
    _cachedSegmentByDevice = null;
    _cachedGroupSize = null;
    _cachedEffectivePixelCount = null;
  }

  void activateSegments(List<SegmentConfig> segments) {
    for (var config in segments) {
      final device = ledfx.devices.devices[config.deviceID];
      if (device == null) continue;
      if (!device.isActive) device.activate();
      device.addSegment(config);
    }
  }

  void deactivateSegments() {
    for (var device in devices) {
      device.clearVirtualSegments(id);
    }
  }

  void updateSegments(List<SegmentConfig> segments) {}

  setFallback() {}
  clearFrame() {}

  void flush(NdArray? pixels) {
    pixels = pixels ?? assembledFrame();
  }

  NdArray assembledFrame() {}

  SegmentConfig validateSegment(SegmentConfig segment) {
    final device = ledfx.devices.devices[segment.deviceID];
    if (device == null) {
      throw Exception("Invalid DeviceID - ${segment.deviceID}");
    } else if (segment.start < 0 ||
        segment.end < 0 ||
        segment.start > segment.end ||
        segment.start >= device.pixelCount ||
        segment.end >= device.pixelCount) {
      debugPrint(
        "Invalid segment pixels in Virtual '${config.name}': segment('${device.name}' (${segment.start}, ${segment.end})) valid pixels between (0, ${device.pixelCount - 1})",
      );

      int start = 0;
      int end = 0;
      if (segment.start < 0) start = 0;
      if (segment.end < 0) end = 0;
      if (segment.start > segment.end) start = end;
      if (segment.start >= device.pixelCount) start = device.pixelCount - 1;
      if (segment.end >= device.pixelCount) end = device.pixelCount - 1;

      return SegmentConfig(segment.deviceID, start, end, segment.inverted);
    }
    return segment;
  }
}

class Virtuals with Iterable<MapEntry<String, Virtual>> {
  // Singleton instance
  static Virtuals? _instance;

  factory Virtuals({required LEDFx ledfx}) {
    _instance ??= Virtuals._(ledfx: ledfx);
    return _instance!;
  }

  Virtuals._({required this.ledfx}) {
    _paused = false;
    _virtuals = {};

    ledfx.events.addListener((e) {
      fireAllFallbacks();
      clearAllEffects();
    }, LEDFxEvent.CORE_SHUTDOWN);
  }

  final LEDFx ledfx;
  late bool _paused;
  late Map _virtuals;
  final Map<String, Virtual> virtuals = {};
  @override
  Iterator<MapEntry<String, Virtual>> get iterator => virtuals.entries.iterator;

  fireAllFallbacks() {
    virtuals.forEach((k, v) {
      v.setFallback();
    });
  }

  clearAllEffects() {
    virtuals.forEach((k, v) {
      v.clearFrame();
    });
  }

  createVirtual({String? id, required VirtualConfig config}) {
    id = id ?? nanoid(10);
    virtuals[id] = Virtual(id: id, config: config, ledfx: ledfx);
  }

  destroyVirtual(String id) {
    if (!virtuals.keys.contains(id)) return;
    virtuals[id]!.del();
    virtuals.removeWhere((k, _) => k == id);
  }

  Virtual create(String id, VirtualConfig config) {}

  void pauseAll() {}

  void resetForCore(LEDFx ledfx) {}

  void checkAndDeactivateDevices() {}
}
