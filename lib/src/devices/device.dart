import 'dart:developer';
import 'dart:io';
import 'dart:math' hide log;

import 'package:flutter/foundation.dart';
import 'package:ledfx/src/core.dart';
import 'package:ledfx/src/devices/packets.dart';
import 'package:ledfx/src/devices/utils.dart';
import 'package:ledfx/src/devices/wled.dart';
import 'package:ledfx/src/effects/utils.dart';
import 'package:ledfx/src/events.dart';
import 'package:ledfx/src/virtual.dart';
import 'package:ledfx/utils.dart';
import 'package:n_dimensional_array/n_dimensional_array.dart';
import 'package:nanoid/nanoid.dart';

class DeviceConfig {
  String? address;
  String name;
  String type;
  int pixelCount;
  bool rgbwLED;
  WLEDSyncMode? syncMode;
  int? rows;

  DeviceConfig({
    required this.pixelCount,
    required this.rgbwLED,
    required this.name,
    required this.type,
    this.syncMode,
    this.address,
    this.rows,
  });
}

class Devices extends Iterable<MapEntry<String, Device>> {
  final LEDFx ledfx;

  Map<String, Device> devices = {};
  @override
  Iterator<MapEntry<String, Device>> get iterator => devices.entries.iterator;

  Devices({required this.ledfx}) {
    ledfx.events.addListener((e) {
      deactivateDevices();
    }, LEDFxEvent.CORE_SHUTDOWN);
  }

  deactivateDevices() {
    devices.forEach((_, v) {
      v.deactivate();
    });
  }

  Device? getDevice(String id) => devices[id];

  Future<void> initialiseDevices() async {
    List<Future<void>> asyncDevices = [];
    devices.forEach((k, v) {
      if (v is AsyncInitDevice) {
        asyncDevices.add((v as AsyncInitDevice).initialize());
      }
    });

    try {
      await Future.wait(asyncDevices);
    } catch (e) {
      print(e.toString());
    }
  }

  Device create(
    String id,
    String deviceType,
    DeviceConfig config,
    LEDFx ledfx,
  ) {
    Device d;
    switch (deviceType) {
      case "wled":
        d = WLEDDevice(
          ipAddr: config.address!,
          syncMode: config.syncMode!,
          id: id,
          ledfx: ledfx,
          config: config,
        );
      default:
        d = WLEDDevice(
          ipAddr: config.address!,
          syncMode: config.syncMode!,
          id: id,
          ledfx: ledfx,
          config: config,
        );
    }

    devices[id] = d;
    return d;
  }

  //Creates New Device
  Future<Device?> addNewDevice(DeviceConfig config) async {
    String resolvedDestination = "";
    final String deviceType = config.type;
    if (config.address != null) {
      final ipAddr = cleanIPaddress(config.address!);
      try {
        resolvedDestination = await resolveDestination(ipAddr);
        if (resolvedDestination == "") throw Exception("could not be resolved");
      } catch (e) {
        throw Exception(
          "device could not be resolved -- $ipAddr, skipping device",
        );
      }

      if (resolvedDestination.isNotEmpty) {
        ledfx.devices.devices.forEach((k, v) {
          if ((v is NetworkedDevice) &&
              (v.ipAddr == ipAddr || v.ipAddr == resolvedDestination)) {
            runDeviceIPtests(deviceType, ipAddr, v);
          }
        });
      }
    }

    String WLEDname = "";
    WLEDConfig? wledConfig;
    if (deviceType == "wled") {
      final wled = WLED(ipAddr: resolvedDestination);
      wledConfig = await wled.getConfig();
      if (wledConfig == null) {
        throw Exception("could not fetch config of wled device");
      }
      if (config.name.isNotEmpty) {
        WLEDname = config.name;
      } else if (wledConfig.name == "WLED") {
        WLEDname = "${wledConfig.name} - ${wledConfig.mac}".toUpperCase();
      } else {
        WLEDname = wledConfig.name;
      }
      // TODO: check support for DDP
      final WLEDSyncMode syncMode = WLEDSyncMode.udp;

      config
        ..name = WLEDname
        ..pixelCount = wledConfig.ledCount
        ..rgbwLED = config.rgbwLED
        ..syncMode = syncMode
        ..rows = (wledConfig.rows == null)
            ? 1
            : int.tryParse(wledConfig.rows!) ?? 1;
    }

    final deviceID = nanoid(10);
    final device = ledfx.devices.create(deviceID, deviceType, config, ledfx);
    if (device is AsyncInitDevice) {
      await (device as AsyncInitDevice).initialize();
    }
    config = device.config;
    if (deviceType == "wled") {
      config.name = WLEDname;
    }
    ledfx.config.devices.add({
      "id": device.id,
      "type": device.type,
      "config": config,
    });

    final virtualID = nanoid(10);
    int virtualConfigRows = 1;
    if (deviceType == "wled" && wledConfig != null && wledConfig.rows != null) {
      virtualConfigRows = int.tryParse(wledConfig.rows!) ?? 1;
    }
    final segments = [
      SegmentConfig(device.id, 0, config.pixelCount - 1, false),
    ];

    final virtualConfig = VirtualConfig(
      name: device.name,
      deviceID: deviceID,
      rows: virtualConfigRows,
      autoGenerated: false,
    );
    final virtual = ledfx.virtuals.create(virtualID, virtualConfig);

    virtual.updateSegments(segments);
    ledfx.config.virtuals.add({
      "id": virtual.id,
      "config": virtual.config,
      "segments": virtual.segments,
      "deviceID": device.id,
      "autoGenerated": virtual.autoGenerated,
    });
    virtual.virtualConfig = ledfx.config.virtuals.last;

    ledfx.events.fireEvent(DeviceCreatedEvent(device.name));
    await device.postamble();

    // TODO: save config
    return device;
  }

  void runDeviceIPtests(String deviceType, String ipAddr, Device v) {}
}

abstract interface class AsyncInitDevice {
  Future<void> initialize();
}

abstract class Device {
  final String id;
  final LEDFx ledfx;
  final DeviceConfig config;
  String get name => config.name;
  int get pixelCount => config.pixelCount;
  String get type => config.type;

  final int centerOffset;
  late int _refreshRate;
  int get maxRefreshRate => _refreshRate;
  int get refreshRate => () {
    if (priorityVirtual != null) {
      return priorityVirtual!.refreshRate;
    } else {
      return 30;
    }
  }();
  Device({
    required this.id,
    required this.ledfx,
    required this.config,
    int? refreshRate,
    this.centerOffset = 0,
  }) {
    _refreshRate = refreshRate ?? 60;
  }

  bool _active = false;
  bool get isActive => _active;

  bool _online = true;
  bool get isOnline => _online;

  List<Float32List>? _pixels;

  List<Virtual>? _cachedVirtualsObjs;
  List<Virtual> get _virtualObjs => () {
    if (_cachedVirtualsObjs != null) return _cachedVirtualsObjs!;
    final vs = <Virtual>[];
    for (var id in virtuals) {
      if (ledfx.virtuals.virtuals.containsKey(id)) {
        vs.add(ledfx.virtuals.virtuals[id]!);
      }
    }
    _cachedVirtualsObjs = vs;
    return _cachedVirtualsObjs!;
  }();
  List<String> get activeVirtuals =>
      _virtualObjs.where((v) => v.active).map((v) => v.id).toList();
  List<String>? _cachedVirtuals;
  List<String> get virtuals => () {
    if (_cachedVirtuals != null) return _cachedVirtuals!;
    _cachedVirtuals = _segments.map((s) => s.deviceID).toList();
    return _cachedVirtuals!;
  }();

  List<SegmentConfig> _segments = [];

  void activate() {
    _pixels = List.filled(pixelCount, Float32List(3));
    _active = true;
  }

  void del() {
    if (isActive) deactivate();
  }

  void deactivate() {
    _pixels = null;
    _active = false;
  }

  void invalidateCache() {
    _cachedPriorityVirtual = null;
    _cachedVirtualsObjs = null;
    _cachedVirtuals = null;
  }

  void setOffline() {
    deactivate();
    _online = false;
    ledfx.events.fireEvent(DevicesUpdatedEvent(id));
  }

  ///Flushes the provided data to the device. This abstract method must be
  ///overwritten by the device implementation.
  void flush(List<Float32List> data) {
    return;
  }

  void configUpdated({
    required String id,
    required String name,
    required LEDFx ledfx,
    int? refreshRate,
    int centerOffset = 0,
    required int pixelCount,
  }) {
    return;
  }

  updateConfig({
    required String id,
    required String name,
    required LEDFx ledfx,
    int? refreshRate,
    int centerOffset = 0,
    required int pixelCount,
  }) {
    configUpdated(
      id: id,
      name: name,
      ledfx: ledfx,
      refreshRate: refreshRate,
      centerOffset: centerOffset,
      pixelCount: pixelCount,
    );

    for (var e in ledfx.virtuals) {
      if (e.value.deviceID == id) {
        final segments = [SegmentConfig(id, 0, pixelCount - 1, false)];
        e.value.updateSegments(segments);
        e.value.invalidateCache();
      }
    }

    for (var v in _virtualObjs) {
      v.deactivateSegments();
      v.activateSegments(v.segments);
    }
  }

  Future<void> postamble() async {
    return;
  }

  void updatePixels(
    String virtualID,
    List<(List<Float32List>, int, int)> data,
  ) {
    if (_active == false) {
      debugPrint("Can't update inactive device: $name");
      return;
    }

    for (final (pixels, _, _) in data) {
      final ndArr = NdArray.fromList(pixels);
      if (ndArr.shape.isNotEmpty && ndArr.shape[0] != 0) {
        if (ndArr.shape.first == 3 ||
            (_pixels != null &&
                NdArray.fromList(_pixels!).shape == ndArr.shape)) {
          _pixels = pixels;
        }
      }
    }

    if (priorityVirtual != null) {
      if (virtualID == priorityVirtual!.id) {
        final frame = assembleFrame();
        if (frame == null) return;
        flush(frame);
        print("flushing Device");
        ledfx.events.fireEvent(DeviceUpdateEvent(id, frame));
      }
    }
  }

  List<Float32List>? assembleFrame() {
    if (_pixels == null) return null;
    List<Float32List> frame = _pixels!;
    if (centerOffset > 0) frame = rollList(frame, centerOffset);
    return frame;
  }

  // Returns the first virtual that has the highest refresh rate of all virtuals
  // associated with this device
  Virtual? _cachedPriorityVirtual;
  Virtual? get priorityVirtual {
    if (_cachedPriorityVirtual != null) return _cachedPriorityVirtual;

    if (!_virtualObjs.any((v) => v.active)) return null;

    final refreshRate = _virtualObjs
        .where((v) => v.active)
        .map((v) => v.refreshRate)
        .reduce(max);

    final Virtual priority = _virtualObjs.firstWhere(
      (virtual) => virtual.refreshRate == refreshRate,
    );

    _cachedPriorityVirtual = priority;
    return _cachedPriorityVirtual;
  }

  void addSegment(SegmentConfig config, [bool force = false]) {
    for (var i in _segments) {
      if (i.deviceID == config.deviceID) continue;

      final overlap = (min(i.end, config.end) - max(i.end, config.start) + 1);

      if (overlap > 0) {
        final virtualName = ledfx.virtuals.virtuals[config.deviceID]?.name;
        final blockingVirtual = ledfx.virtuals.virtuals[i.deviceID];

        if (virtualName == null || blockingVirtual == null) {
          throw Exception("no device found");
        }

        if (force) {
          blockingVirtual.deactivate();
        } else {
          throw Exception(
            "failed to activate effect!. $virtualName overlaps with active virtual ${blockingVirtual.name}",
          );
        }
      }
    }

    // if the segment is from a new device, we need to recheck our priority virtual
    if (!_segments.any((seg) => seg.deviceID == config.deviceID)) {
      invalidateCache();
    }
    _segments.add(config);
    invalidateCache();
  }

  void clearVirtualSegments(String id) {
    final newSegments = <SegmentConfig>[];
    for (var segment in _segments) {
      if (segment.deviceID != id) {
        newSegments.add(segment);
      } else {
        if (_pixels != null && ledfx.config.flushOnDeactivate) {
          for (int i = segment.start; i <= segment.end; i++) {
            final Float32List zeroRow = Float32List(3);
            _pixels![i] = zeroRow;
          }
        }
      }
    }
    _segments = newSegments;
    if (priorityVirtual != null && priorityVirtual!.id == id) {
      invalidateCache();
    }
  }

  void clearSegments() {
    _segments = [];
    invalidateCache();
  }
}

abstract class NetworkedDevice extends Device implements AsyncInitDevice {
  NetworkedDevice({
    super.refreshRate,
    required String ipAddr,
    required super.id,
    required super.ledfx,
    required super.config,
  }) {
    config.address = ipAddr;
  }

  String get ipAddr => config.address!;

  String? _destination;
  String? get destination => () {
    if (_destination == null) {
      resolveAddress();
      return null;
    } else {
      return _destination!;
    }
  }();
  set destination(String? dest) => _destination = dest;

  @override
  Future<void> initialize() async {
    _destination = null;
    await resolveAddress();
  }

  @override
  void activate() {
    if (_destination == null) {
      debugPrint("Error: Not Online");
      resolveAddress().then((_) {
        activate();
      });
    } else {
      _online = true;
      super.activate();
    }
  }

  Future<void> resolveAddress([VoidCallback? callback]) async {
    try {
      _destination = await resolveDestination(ipAddr);
      _online = true;
      if (callback != null) callback();
    } catch (e) {
      _online = false;
      debugPrint(e.toString());
    }
  }
}

abstract class UDPDevice extends NetworkedDevice {
  UDPDevice({
    required super.ipAddr,
    super.refreshRate,
    required this.port,
    required super.id,
    required super.ledfx,
    required super.config,
  });

  int port;

  RawDatagramSocket? _socket;
  RawDatagramSocket? get socket => _socket;

  @override
  Future<void> activate() async {
    _socket = await RawDatagramSocket.bind(InternetAddress.anyIPv4, 0);
    super.activate();
  }

  @override
  void deactivate() {
    super.deactivate();
    _socket = null;
  }
}

class RealtimeUDPDevice extends UDPDevice {
  RealtimeUDPDevice({
    required super.ipAddr,
    required super.port,
    super.refreshRate,
    required this.udpPacketType,
    this.timeout = 1,
    this.minimizeTraffic = true,
    required super.id,
    required super.ledfx,
    required super.config,
  }) : lastFrame = List.filled(
         config.pixelCount,
         Float32List.fromList(List.filled(3, -1)),
       ),
       lastFrameSendTime = DateTime.now().millisecondsSinceEpoch,
       deviceType = "UDP Device";

  String deviceType;
  String udpPacketType;
  int timeout;
  bool minimizeTraffic;

  late List<Float32List> lastFrame;
  late int lastFrameSendTime;

  @override
  void flush(List<Float32List> data) {
    try {
      chooseAndSend(data);
      lastFrame = data;
    } catch (e) {
      log("Error: ${e.toString()}");
      activate();
    }
  }

  void chooseAndSend(List<Float32List> data) {
    final int frameSize = data.length;
    final bool frameIsSame = minimizeTraffic && data == lastFrame;
    log("Frame Size/Pixel Count = $frameSize");

    switch ((udpPacketType, frameSize)) {
      case ("DRGB", <= 490):
        final udpData = Packets.buidDRGBpacket(data, timeout);
        transmitPacket(udpData, frameIsSame);
        break;
      case ("WARLS", <= 255):
        final udpData = Packets.buildWARLSpacket(data, timeout);
        transmitPacket(udpData, frameIsSame);
        break;
      case ("DNRGB", _):
        final numberOfPackets = (frameSize / 489).ceil();
        for (int i = 0; i < numberOfPackets; i++) {
          int start = i * 489;
          int end = start + 489;
          final udpData = Packets.buidDNRGBpacket(
            data.getRange(start, end).toList(),
            start,
            timeout,
          );
          transmitPacket(udpData, frameIsSame);
        }
        break;
      default:
        log(
          """UDP packet is configured incorrectly (please choose a packet that supports $pixelCount LEDs): 
          https://kno.wled.ge/interfaces/udp-realtime/#udp-realtime \n Falling back to supported udp packet.""",
        );

        if (frameSize < 255) {
          //DRGB
          final udpData = Packets.buidDRGBpacket(data, timeout);
          transmitPacket(udpData, frameIsSame);
        } else {
          // DNRGB
          final numberOfPackets = (frameSize / 489).ceil();
          for (int i = 0; i < numberOfPackets; i++) {
            int start = i * 489;
            int end = start + 489;
            final udpData = Packets.buidDNRGBpacket(
              data.getRange(start, end).toList(),
              start,
              timeout,
            );
            transmitPacket(udpData, frameIsSame);
          }
        }
    }
  }

  void transmitPacket(packet, bool frameIsSame) {
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    if (frameIsSame) {
      final halfTimeout =
          ((((timeout * refreshRate) - 1) ~/ 2) / refreshRate) * 1000;

      if (timestamp > lastFrameSendTime + halfTimeout) {
        if (_destination != null) {
          _socket!.send([111], InternetAddress(_destination!), port);
          lastFrameSendTime = timestamp;
        }
      }
    } else {
      if (_destination != null) {
        _socket!.send([111], InternetAddress(_destination!), port);
        lastFrameSendTime = timestamp;
      }
    }
  }
}
