// Generated FFI bindings for aubio audio analysis library
//
// This file contains the low-level FFI bindings for aubio.
// Use the higher-level classes in flutter_aubio for a more convenient API.

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// generates aubio bindings
class AubioBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
  _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  AubioBindings(ffi.DynamicLibrary dynamicLibrary)
    : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  AubioBindings.fromLookup(
    ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName) lookup,
  ) : _lookup = lookup;

  /// fvec_t buffer creation function
  ///
  /// \param length the length of the buffer to create
  ffi.Pointer<fvec_t> new_fvec(int length) {
    return _new_fvec(length);
  }

  late final _new_fvecPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<fvec_t> Function(uint_t)>>(
        'new_fvec',
      );
  late final _new_fvec = _new_fvecPtr
      .asFunction<ffi.Pointer<fvec_t> Function(int)>();

  /// fvec_t buffer deletion function
  ///
  /// \param s buffer to delete as returned by new_fvec()
  void del_fvec(ffi.Pointer<fvec_t> s) {
    return _del_fvec(s);
  }

  late final _del_fvecPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>)>>(
        'del_fvec',
      );
  late final _del_fvec = _del_fvecPtr
      .asFunction<void Function(ffi.Pointer<fvec_t>)>();

  /// read sample value in a buffer
  ///
  /// \param s vector to read from
  /// \param position sample position to read from
  double fvec_get_sample(ffi.Pointer<fvec_t> s, int position) {
    return _fvec_get_sample(s, position);
  }

  late final _fvec_get_samplePtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<fvec_t>, uint_t)>>(
        'fvec_get_sample',
      );
  late final _fvec_get_sample = _fvec_get_samplePtr
      .asFunction<double Function(ffi.Pointer<fvec_t>, int)>();

  /// write sample value in a buffer
  ///
  /// \param s vector to write to
  /// \param data value to write in s->data[position]
  /// \param position sample position to write to
  void fvec_set_sample(ffi.Pointer<fvec_t> s, double data, int position) {
    return _fvec_set_sample(s, data, position);
  }

  late final _fvec_set_samplePtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<fvec_t>, smpl_t, uint_t)
        >
      >('fvec_set_sample');
  late final _fvec_set_sample = _fvec_set_samplePtr
      .asFunction<void Function(ffi.Pointer<fvec_t>, double, int)>();

  /// read data from a buffer
  ///
  /// \param s vector to read from
  ffi.Pointer<smpl_t> fvec_get_data(ffi.Pointer<fvec_t> s) {
    return _fvec_get_data(s);
  }

  late final _fvec_get_dataPtr =
      _lookup<
        ffi.NativeFunction<ffi.Pointer<smpl_t> Function(ffi.Pointer<fvec_t>)>
      >('fvec_get_data');
  late final _fvec_get_data = _fvec_get_dataPtr
      .asFunction<ffi.Pointer<smpl_t> Function(ffi.Pointer<fvec_t>)>();

  /// print out fvec data
  ///
  /// \param s vector to print out
  void fvec_print(ffi.Pointer<fvec_t> s) {
    return _fvec_print(s);
  }

  late final _fvec_printPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>)>>(
        'fvec_print',
      );
  late final _fvec_print = _fvec_printPtr
      .asFunction<void Function(ffi.Pointer<fvec_t>)>();

  /// set all elements to a given value
  ///
  /// \param s vector to modify
  /// \param val value to set elements to
  void fvec_set_all(ffi.Pointer<fvec_t> s, double val) {
    return _fvec_set_all(s, val);
  }

  late final _fvec_set_allPtr =
      _lookup<
        ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>, smpl_t)>
      >('fvec_set_all');
  late final _fvec_set_all = _fvec_set_allPtr
      .asFunction<void Function(ffi.Pointer<fvec_t>, double)>();

  /// set all elements to zero
  ///
  /// \param s vector to modify
  void fvec_zeros(ffi.Pointer<fvec_t> s) {
    return _fvec_zeros(s);
  }

  late final _fvec_zerosPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>)>>(
        'fvec_zeros',
      );
  late final _fvec_zeros = _fvec_zerosPtr
      .asFunction<void Function(ffi.Pointer<fvec_t>)>();

  /// set all elements to ones
  ///
  /// \param s vector to modify
  void fvec_ones(ffi.Pointer<fvec_t> s) {
    return _fvec_ones(s);
  }

  late final _fvec_onesPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>)>>(
        'fvec_ones',
      );
  late final _fvec_ones = _fvec_onesPtr
      .asFunction<void Function(ffi.Pointer<fvec_t>)>();

  /// revert order of vector elements
  ///
  /// \param s vector to revert
  void fvec_rev(ffi.Pointer<fvec_t> s) {
    return _fvec_rev(s);
  }

  late final _fvec_revPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>)>>(
        'fvec_rev',
      );
  late final _fvec_rev = _fvec_revPtr
      .asFunction<void Function(ffi.Pointer<fvec_t>)>();

  /// apply weight to vector
  ///
  /// If the weight vector is longer than s, only the first elements are used. If
  /// the weight vector is shorter than s, the last elements of s are not weighted.
  ///
  /// \param s vector to weight
  /// \param weight weighting coefficients
  void fvec_weight(ffi.Pointer<fvec_t> s, ffi.Pointer<fvec_t> weight) {
    return _fvec_weight(s, weight);
  }

  late final _fvec_weightPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<fvec_t>, ffi.Pointer<fvec_t>)
        >
      >('fvec_weight');
  late final _fvec_weight = _fvec_weightPtr
      .asFunction<void Function(ffi.Pointer<fvec_t>, ffi.Pointer<fvec_t>)>();

  /// make a copy of a vector
  ///
  /// \param s source vector
  /// \param t vector to copy to
  void fvec_copy(ffi.Pointer<fvec_t> s, ffi.Pointer<fvec_t> t) {
    return _fvec_copy(s, t);
  }

  late final _fvec_copyPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<fvec_t>, ffi.Pointer<fvec_t>)
        >
      >('fvec_copy');
  late final _fvec_copy = _fvec_copyPtr
      .asFunction<void Function(ffi.Pointer<fvec_t>, ffi.Pointer<fvec_t>)>();

  /// make a copy of a vector, applying weights to each element
  ///
  /// \param in input vector
  /// \param weight weights vector
  /// \param out output vector
  void fvec_weighted_copy(
    ffi.Pointer<fvec_t> in$,
    ffi.Pointer<fvec_t> weight,
    ffi.Pointer<fvec_t> out,
  ) {
    return _fvec_weighted_copy(in$, weight, out);
  }

  late final _fvec_weighted_copyPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<fvec_t>,
            ffi.Pointer<fvec_t>,
            ffi.Pointer<fvec_t>,
          )
        >
      >('fvec_weighted_copy');
  late final _fvec_weighted_copy = _fvec_weighted_copyPtr
      .asFunction<
        void Function(
          ffi.Pointer<fvec_t>,
          ffi.Pointer<fvec_t>,
          ffi.Pointer<fvec_t>,
        )
      >();

  /// cvec_t buffer creation function
  ///
  /// This function creates a cvec_t structure holding two arrays of size
  /// [length/2+1], corresponding to the norm and phase values of the
  /// spectral frame. The length stored in the structure is the actual size of both
  /// arrays, not the length of the complex and symmetrical vector, specified as
  /// creation argument.
  ///
  /// \param length the length of the buffer to create
  ffi.Pointer<cvec_t> new_cvec(int length) {
    return _new_cvec(length);
  }

  late final _new_cvecPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<cvec_t> Function(uint_t)>>(
        'new_cvec',
      );
  late final _new_cvec = _new_cvecPtr
      .asFunction<ffi.Pointer<cvec_t> Function(int)>();

  /// cvec_t buffer deletion function
  ///
  /// \param s buffer to delete as returned by new_cvec()
  void del_cvec(ffi.Pointer<cvec_t> s) {
    return _del_cvec(s);
  }

  late final _del_cvecPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<cvec_t>)>>(
        'del_cvec',
      );
  late final _del_cvec = _del_cvecPtr
      .asFunction<void Function(ffi.Pointer<cvec_t>)>();

  /// write norm value in a complex buffer
  ///
  /// This is equivalent to:
  /// \code
  /// s->norm[position] = val;
  /// \endcode
  ///
  /// \param s vector to write to
  /// \param val norm value to write in s->norm[position]
  /// \param position sample position to write to
  void cvec_norm_set_sample(ffi.Pointer<cvec_t> s, double val, int position) {
    return _cvec_norm_set_sample(s, val, position);
  }

  late final _cvec_norm_set_samplePtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<cvec_t>, smpl_t, uint_t)
        >
      >('cvec_norm_set_sample');
  late final _cvec_norm_set_sample = _cvec_norm_set_samplePtr
      .asFunction<void Function(ffi.Pointer<cvec_t>, double, int)>();

  /// write phase value in a complex buffer
  ///
  /// This is equivalent to:
  /// \code
  /// s->phas[position] = val;
  /// \endcode
  ///
  /// \param s vector to write to
  /// \param val phase value to write in s->phas[position]
  /// \param position sample position to write to
  void cvec_phas_set_sample(ffi.Pointer<cvec_t> s, double val, int position) {
    return _cvec_phas_set_sample(s, val, position);
  }

  late final _cvec_phas_set_samplePtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<cvec_t>, smpl_t, uint_t)
        >
      >('cvec_phas_set_sample');
  late final _cvec_phas_set_sample = _cvec_phas_set_samplePtr
      .asFunction<void Function(ffi.Pointer<cvec_t>, double, int)>();

  /// read norm value from a complex buffer
  ///
  /// This is equivalent to:
  /// \code
  /// smpl_t foo = s->norm[position];
  /// \endcode
  ///
  /// \param s vector to read from
  /// \param position sample position to read from
  double cvec_norm_get_sample(ffi.Pointer<cvec_t> s, int position) {
    return _cvec_norm_get_sample(s, position);
  }

  late final _cvec_norm_get_samplePtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<cvec_t>, uint_t)>>(
        'cvec_norm_get_sample',
      );
  late final _cvec_norm_get_sample = _cvec_norm_get_samplePtr
      .asFunction<double Function(ffi.Pointer<cvec_t>, int)>();

  /// read phase value from a complex buffer
  ///
  /// This is equivalent to:
  /// \code
  /// smpl_t foo = s->phas[position];
  /// \endcode
  ///
  /// \param s vector to read from
  /// \param position sample position to read from
  /// \returns the value of the sample at position
  double cvec_phas_get_sample(ffi.Pointer<cvec_t> s, int position) {
    return _cvec_phas_get_sample(s, position);
  }

  late final _cvec_phas_get_samplePtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<cvec_t>, uint_t)>>(
        'cvec_phas_get_sample',
      );
  late final _cvec_phas_get_sample = _cvec_phas_get_samplePtr
      .asFunction<double Function(ffi.Pointer<cvec_t>, int)>();

  /// read norm data from a complex buffer
  ///
  /// \code
  /// smpl_t *data = s->norm;
  /// \endcode
  ///
  /// \param s vector to read from
  ffi.Pointer<smpl_t> cvec_norm_get_data(ffi.Pointer<cvec_t> s) {
    return _cvec_norm_get_data(s);
  }

  late final _cvec_norm_get_dataPtr =
      _lookup<
        ffi.NativeFunction<ffi.Pointer<smpl_t> Function(ffi.Pointer<cvec_t>)>
      >('cvec_norm_get_data');
  late final _cvec_norm_get_data = _cvec_norm_get_dataPtr
      .asFunction<ffi.Pointer<smpl_t> Function(ffi.Pointer<cvec_t>)>();

  /// read phase data from a complex buffer
  ///
  /// This is equivalent to:
  /// \code
  /// smpl_t *data = s->phas;
  /// \endcode
  ///
  /// \param s vector to read from
  ffi.Pointer<smpl_t> cvec_phas_get_data(ffi.Pointer<cvec_t> s) {
    return _cvec_phas_get_data(s);
  }

  late final _cvec_phas_get_dataPtr =
      _lookup<
        ffi.NativeFunction<ffi.Pointer<smpl_t> Function(ffi.Pointer<cvec_t>)>
      >('cvec_phas_get_data');
  late final _cvec_phas_get_data = _cvec_phas_get_dataPtr
      .asFunction<ffi.Pointer<smpl_t> Function(ffi.Pointer<cvec_t>)>();

  /// print out cvec data
  ///
  /// \param s vector to print out
  void cvec_print(ffi.Pointer<cvec_t> s) {
    return _cvec_print(s);
  }

  late final _cvec_printPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<cvec_t>)>>(
        'cvec_print',
      );
  late final _cvec_print = _cvec_printPtr
      .asFunction<void Function(ffi.Pointer<cvec_t>)>();

  /// make a copy of a vector
  ///
  /// \param s source vector
  /// \param t vector to copy to
  void cvec_copy(ffi.Pointer<cvec_t> s, ffi.Pointer<cvec_t> t) {
    return _cvec_copy(s, t);
  }

  late final _cvec_copyPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<cvec_t>, ffi.Pointer<cvec_t>)
        >
      >('cvec_copy');
  late final _cvec_copy = _cvec_copyPtr
      .asFunction<void Function(ffi.Pointer<cvec_t>, ffi.Pointer<cvec_t>)>();

  /// set all norm elements to a given value
  ///
  /// \param s vector to modify
  /// \param val value to set elements to
  void cvec_norm_set_all(ffi.Pointer<cvec_t> s, double val) {
    return _cvec_norm_set_all(s, val);
  }

  late final _cvec_norm_set_allPtr =
      _lookup<
        ffi.NativeFunction<ffi.Void Function(ffi.Pointer<cvec_t>, smpl_t)>
      >('cvec_norm_set_all');
  late final _cvec_norm_set_all = _cvec_norm_set_allPtr
      .asFunction<void Function(ffi.Pointer<cvec_t>, double)>();

  /// set all norm elements to zero
  ///
  /// \param s vector to modify
  void cvec_norm_zeros(ffi.Pointer<cvec_t> s) {
    return _cvec_norm_zeros(s);
  }

  late final _cvec_norm_zerosPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<cvec_t>)>>(
        'cvec_norm_zeros',
      );
  late final _cvec_norm_zeros = _cvec_norm_zerosPtr
      .asFunction<void Function(ffi.Pointer<cvec_t>)>();

  /// set all norm elements to one
  ///
  /// \param s vector to modify
  void cvec_norm_ones(ffi.Pointer<cvec_t> s) {
    return _cvec_norm_ones(s);
  }

  late final _cvec_norm_onesPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<cvec_t>)>>(
        'cvec_norm_ones',
      );
  late final _cvec_norm_ones = _cvec_norm_onesPtr
      .asFunction<void Function(ffi.Pointer<cvec_t>)>();

  /// set all phase elements to a given value
  ///
  /// \param s vector to modify
  /// \param val value to set elements to
  void cvec_phas_set_all(ffi.Pointer<cvec_t> s, double val) {
    return _cvec_phas_set_all(s, val);
  }

  late final _cvec_phas_set_allPtr =
      _lookup<
        ffi.NativeFunction<ffi.Void Function(ffi.Pointer<cvec_t>, smpl_t)>
      >('cvec_phas_set_all');
  late final _cvec_phas_set_all = _cvec_phas_set_allPtr
      .asFunction<void Function(ffi.Pointer<cvec_t>, double)>();

  /// set all phase elements to zero
  ///
  /// \param s vector to modify
  void cvec_phas_zeros(ffi.Pointer<cvec_t> s) {
    return _cvec_phas_zeros(s);
  }

  late final _cvec_phas_zerosPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<cvec_t>)>>(
        'cvec_phas_zeros',
      );
  late final _cvec_phas_zeros = _cvec_phas_zerosPtr
      .asFunction<void Function(ffi.Pointer<cvec_t>)>();

  /// set all phase elements to one
  ///
  /// \param s vector to modify
  void cvec_phas_ones(ffi.Pointer<cvec_t> s) {
    return _cvec_phas_ones(s);
  }

  late final _cvec_phas_onesPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<cvec_t>)>>(
        'cvec_phas_ones',
      );
  late final _cvec_phas_ones = _cvec_phas_onesPtr
      .asFunction<void Function(ffi.Pointer<cvec_t>)>();

  /// set all norm and phas elements to zero
  ///
  /// \param s vector to modify
  void cvec_zeros(ffi.Pointer<cvec_t> s) {
    return _cvec_zeros(s);
  }

  late final _cvec_zerosPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<cvec_t>)>>(
        'cvec_zeros',
      );
  late final _cvec_zeros = _cvec_zerosPtr
      .asFunction<void Function(ffi.Pointer<cvec_t>)>();

  /// take logarithmic magnitude
  ///
  /// \param s input cvec to compress
  /// \param lambda value to use for normalisation
  ///
  /// \f$ S_k = log( \lambda * S_k + 1 ) \f$
  void cvec_logmag(ffi.Pointer<cvec_t> s, double lambda) {
    return _cvec_logmag(s, lambda);
  }

  late final _cvec_logmagPtr =
      _lookup<
        ffi.NativeFunction<ffi.Void Function(ffi.Pointer<cvec_t>, smpl_t)>
      >('cvec_logmag');
  late final _cvec_logmag = _cvec_logmagPtr
      .asFunction<void Function(ffi.Pointer<cvec_t>, double)>();

  /// lvec_t buffer creation function
  ///
  /// \param length the length of the buffer to create
  ffi.Pointer<lvec_t> new_lvec(int length) {
    return _new_lvec(length);
  }

  late final _new_lvecPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<lvec_t> Function(uint_t)>>(
        'new_lvec',
      );
  late final _new_lvec = _new_lvecPtr
      .asFunction<ffi.Pointer<lvec_t> Function(int)>();

  /// lvec_t buffer deletion function
  ///
  /// \param s buffer to delete as returned by new_lvec()
  void del_lvec(ffi.Pointer<lvec_t> s) {
    return _del_lvec(s);
  }

  late final _del_lvecPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lvec_t>)>>(
        'del_lvec',
      );
  late final _del_lvec = _del_lvecPtr
      .asFunction<void Function(ffi.Pointer<lvec_t>)>();

  /// read sample value in a buffer
  ///
  /// \param s vector to read from
  /// \param position sample position to read from
  double lvec_get_sample(ffi.Pointer<lvec_t> s, int position) {
    return _lvec_get_sample(s, position);
  }

  late final _lvec_get_samplePtr =
      _lookup<ffi.NativeFunction<lsmp_t Function(ffi.Pointer<lvec_t>, uint_t)>>(
        'lvec_get_sample',
      );
  late final _lvec_get_sample = _lvec_get_samplePtr
      .asFunction<double Function(ffi.Pointer<lvec_t>, int)>();

  /// write sample value in a buffer
  ///
  /// \param s vector to write to
  /// \param data value to write in s->data[position]
  /// \param position sample position to write to
  void lvec_set_sample(ffi.Pointer<lvec_t> s, double data, int position) {
    return _lvec_set_sample(s, data, position);
  }

  late final _lvec_set_samplePtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lvec_t>, lsmp_t, uint_t)
        >
      >('lvec_set_sample');
  late final _lvec_set_sample = _lvec_set_samplePtr
      .asFunction<void Function(ffi.Pointer<lvec_t>, double, int)>();

  /// read data from a buffer
  ///
  /// \param s vector to read from
  ffi.Pointer<lsmp_t> lvec_get_data(ffi.Pointer<lvec_t> s) {
    return _lvec_get_data(s);
  }

  late final _lvec_get_dataPtr =
      _lookup<
        ffi.NativeFunction<ffi.Pointer<lsmp_t> Function(ffi.Pointer<lvec_t>)>
      >('lvec_get_data');
  late final _lvec_get_data = _lvec_get_dataPtr
      .asFunction<ffi.Pointer<lsmp_t> Function(ffi.Pointer<lvec_t>)>();

  /// print out lvec data
  ///
  /// \param s vector to print out
  void lvec_print(ffi.Pointer<lvec_t> s) {
    return _lvec_print(s);
  }

  late final _lvec_printPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lvec_t>)>>(
        'lvec_print',
      );
  late final _lvec_print = _lvec_printPtr
      .asFunction<void Function(ffi.Pointer<lvec_t>)>();

  /// set all elements to a given value
  ///
  /// \param s vector to modify
  /// \param val value to set elements to
  void lvec_set_all(ffi.Pointer<lvec_t> s, double val) {
    return _lvec_set_all(s, val);
  }

  late final _lvec_set_allPtr =
      _lookup<
        ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lvec_t>, smpl_t)>
      >('lvec_set_all');
  late final _lvec_set_all = _lvec_set_allPtr
      .asFunction<void Function(ffi.Pointer<lvec_t>, double)>();

  /// set all elements to zero
  ///
  /// \param s vector to modify
  void lvec_zeros(ffi.Pointer<lvec_t> s) {
    return _lvec_zeros(s);
  }

  late final _lvec_zerosPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lvec_t>)>>(
        'lvec_zeros',
      );
  late final _lvec_zeros = _lvec_zerosPtr
      .asFunction<void Function(ffi.Pointer<lvec_t>)>();

  /// set all elements to ones
  ///
  /// \param s vector to modify
  void lvec_ones(ffi.Pointer<lvec_t> s) {
    return _lvec_ones(s);
  }

  late final _lvec_onesPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lvec_t>)>>(
        'lvec_ones',
      );
  late final _lvec_ones = _lvec_onesPtr
      .asFunction<void Function(ffi.Pointer<lvec_t>)>();

  /// fmat_t buffer creation function
  ///
  /// \param length the length of the matrix to create
  /// \param height the height of the matrix to create
  ffi.Pointer<fmat_t> new_fmat(int height, int length) {
    return _new_fmat(height, length);
  }

  late final _new_fmatPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<fmat_t> Function(uint_t, uint_t)>>(
        'new_fmat',
      );
  late final _new_fmat = _new_fmatPtr
      .asFunction<ffi.Pointer<fmat_t> Function(int, int)>();

  /// fmat_t buffer deletion function
  ///
  /// \param s buffer to delete as returned by new_fmat()
  void del_fmat(ffi.Pointer<fmat_t> s) {
    return _del_fmat(s);
  }

  late final _del_fmatPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fmat_t>)>>(
        'del_fmat',
      );
  late final _del_fmat = _del_fmatPtr
      .asFunction<void Function(ffi.Pointer<fmat_t>)>();

  /// read sample value in a buffer
  ///
  /// \param s vector to read from
  /// \param channel channel to read from
  /// \param position sample position to read from
  double fmat_get_sample(ffi.Pointer<fmat_t> s, int channel, int position) {
    return _fmat_get_sample(s, channel, position);
  }

  late final _fmat_get_samplePtr =
      _lookup<
        ffi.NativeFunction<smpl_t Function(ffi.Pointer<fmat_t>, uint_t, uint_t)>
      >('fmat_get_sample');
  late final _fmat_get_sample = _fmat_get_samplePtr
      .asFunction<double Function(ffi.Pointer<fmat_t>, int, int)>();

  /// write sample value in a buffer
  ///
  /// \param s vector to write to
  /// \param data value to write in s->data[channel][position]
  /// \param channel channel to write to
  /// \param position sample position to write to
  void fmat_set_sample(
    ffi.Pointer<fmat_t> s,
    double data,
    int channel,
    int position,
  ) {
    return _fmat_set_sample(s, data, channel, position);
  }

  late final _fmat_set_samplePtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<fmat_t>, smpl_t, uint_t, uint_t)
        >
      >('fmat_set_sample');
  late final _fmat_set_sample = _fmat_set_samplePtr
      .asFunction<void Function(ffi.Pointer<fmat_t>, double, int, int)>();

  /// read channel vector from a buffer
  ///
  /// \param s vector to read from
  /// \param channel channel to read from
  /// \param output ::fvec_t to output to
  void fmat_get_channel(
    ffi.Pointer<fmat_t> s,
    int channel,
    ffi.Pointer<fvec_t> output,
  ) {
    return _fmat_get_channel(s, channel, output);
  }

  late final _fmat_get_channelPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<fmat_t>, uint_t, ffi.Pointer<fvec_t>)
        >
      >('fmat_get_channel');
  late final _fmat_get_channel = _fmat_get_channelPtr
      .asFunction<
        void Function(ffi.Pointer<fmat_t>, int, ffi.Pointer<fvec_t>)
      >();

  /// get vector buffer from an fmat data
  ///
  /// \param s vector to read from
  /// \param channel channel to read from
  ffi.Pointer<smpl_t> fmat_get_channel_data(
    ffi.Pointer<fmat_t> s,
    int channel,
  ) {
    return _fmat_get_channel_data(s, channel);
  }

  late final _fmat_get_channel_dataPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<smpl_t> Function(ffi.Pointer<fmat_t>, uint_t)
        >
      >('fmat_get_channel_data');
  late final _fmat_get_channel_data = _fmat_get_channel_dataPtr
      .asFunction<ffi.Pointer<smpl_t> Function(ffi.Pointer<fmat_t>, int)>();

  /// read data from a buffer
  ///
  /// \param s vector to read from
  ffi.Pointer<ffi.Pointer<smpl_t>> fmat_get_data(ffi.Pointer<fmat_t> s) {
    return _fmat_get_data(s);
  }

  late final _fmat_get_dataPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<ffi.Pointer<smpl_t>> Function(ffi.Pointer<fmat_t>)
        >
      >('fmat_get_data');
  late final _fmat_get_data = _fmat_get_dataPtr
      .asFunction<
        ffi.Pointer<ffi.Pointer<smpl_t>> Function(ffi.Pointer<fmat_t>)
      >();

  /// print out fmat data
  ///
  /// \param s vector to print out
  void fmat_print(ffi.Pointer<fmat_t> s) {
    return _fmat_print(s);
  }

  late final _fmat_printPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fmat_t>)>>(
        'fmat_print',
      );
  late final _fmat_print = _fmat_printPtr
      .asFunction<void Function(ffi.Pointer<fmat_t>)>();

  /// set all elements to a given value
  ///
  /// \param s vector to modify
  /// \param val value to set elements to
  void fmat_set(ffi.Pointer<fmat_t> s, double val) {
    return _fmat_set(s, val);
  }

  late final _fmat_setPtr =
      _lookup<
        ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fmat_t>, smpl_t)>
      >('fmat_set');
  late final _fmat_set = _fmat_setPtr
      .asFunction<void Function(ffi.Pointer<fmat_t>, double)>();

  /// set all elements to zero
  ///
  /// \param s vector to modify
  void fmat_zeros(ffi.Pointer<fmat_t> s) {
    return _fmat_zeros(s);
  }

  late final _fmat_zerosPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fmat_t>)>>(
        'fmat_zeros',
      );
  late final _fmat_zeros = _fmat_zerosPtr
      .asFunction<void Function(ffi.Pointer<fmat_t>)>();

  /// set all elements to ones
  ///
  /// \param s vector to modify
  void fmat_ones(ffi.Pointer<fmat_t> s) {
    return _fmat_ones(s);
  }

  late final _fmat_onesPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fmat_t>)>>(
        'fmat_ones',
      );
  late final _fmat_ones = _fmat_onesPtr
      .asFunction<void Function(ffi.Pointer<fmat_t>)>();

  /// revert order of vector elements
  ///
  /// \param s vector to revert
  void fmat_rev(ffi.Pointer<fmat_t> s) {
    return _fmat_rev(s);
  }

  late final _fmat_revPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fmat_t>)>>(
        'fmat_rev',
      );
  late final _fmat_rev = _fmat_revPtr
      .asFunction<void Function(ffi.Pointer<fmat_t>)>();

  /// apply weight to vector
  ///
  /// If the weight vector is longer than s, only the first elements are used. If
  /// the weight vector is shorter than s, the last elements of s are not weighted.
  ///
  /// \param s vector to weight
  /// \param weight weighting coefficients
  void fmat_weight(ffi.Pointer<fmat_t> s, ffi.Pointer<fmat_t> weight) {
    return _fmat_weight(s, weight);
  }

  late final _fmat_weightPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<fmat_t>, ffi.Pointer<fmat_t>)
        >
      >('fmat_weight');
  late final _fmat_weight = _fmat_weightPtr
      .asFunction<void Function(ffi.Pointer<fmat_t>, ffi.Pointer<fmat_t>)>();

  /// make a copy of a matrix
  ///
  /// \param s source vector
  /// \param t vector to copy to
  void fmat_copy(ffi.Pointer<fmat_t> s, ffi.Pointer<fmat_t> t) {
    return _fmat_copy(s, t);
  }

  late final _fmat_copyPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<fmat_t>, ffi.Pointer<fmat_t>)
        >
      >('fmat_copy');
  late final _fmat_copy = _fmat_copyPtr
      .asFunction<void Function(ffi.Pointer<fmat_t>, ffi.Pointer<fmat_t>)>();

  /// compute the product of a matrix by a vector
  ///
  /// \param s matrix to compute product with
  /// \param scale vector to compute product with
  /// \param output vector to store restults in
  void fmat_vecmul(
    ffi.Pointer<fmat_t> s,
    ffi.Pointer<fvec_t> scale,
    ffi.Pointer<fvec_t> output,
  ) {
    return _fmat_vecmul(s, scale, output);
  }

  late final _fmat_vecmulPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<fmat_t>,
            ffi.Pointer<fvec_t>,
            ffi.Pointer<fvec_t>,
          )
        >
      >('fmat_vecmul');
  late final _fmat_vecmul = _fmat_vecmulPtr
      .asFunction<
        void Function(
          ffi.Pointer<fmat_t>,
          ffi.Pointer<fvec_t>,
          ffi.Pointer<fvec_t>,
        )
      >();

  /// create window
  ///
  /// \param window_type type of the window to create
  /// \param size length of the window to create (see fvec_set_window())
  ffi.Pointer<fvec_t> new_aubio_window(
    ffi.Pointer<char_t> window_type,
    int size,
  ) {
    return _new_aubio_window(window_type, size);
  }

  late final _new_aubio_windowPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<fvec_t> Function(ffi.Pointer<char_t>, uint_t)
        >
      >('new_aubio_window');
  late final _new_aubio_window = _new_aubio_windowPtr
      .asFunction<ffi.Pointer<fvec_t> Function(ffi.Pointer<char_t>, int)>();

  /// set elements of a vector to window coefficients
  ///
  /// \param window exsting ::fvec_t to use
  /// \param window_type type of the window to create
  ///
  /// List of available window types: "rectangle", "hamming", "hanning",
  /// "hanningz", "blackman", "blackman_harris", "gaussian", "welch", "parzen",
  /// "default".
  ///
  /// "default" is equivalent to "hanningz".
  ///
  /// References:
  ///
  /// - <a href="http://en.wikipedia.org/wiki/Window_function">Window
  /// function</a> on Wikipedia
  /// - Amalia de Götzen, Nicolas Bernardini, and Daniel Arfib. Traditional (?)
  /// implementations of a phase vocoder: the tricks of the trade. In Proceedings of
  /// the International Conference on Digital Audio Effects (DAFx-00), pages 37–44,
  /// Uni- versity of Verona, Italy, 2000.
  /// (<a href="http://www.cs.princeton.edu/courses/archive/spr09/cos325/Bernardini.pdf">
  /// pdf</a>)
  int fvec_set_window(
    ffi.Pointer<fvec_t> window,
    ffi.Pointer<char_t> window_type,
  ) {
    return _fvec_set_window(window, window_type);
  }

  late final _fvec_set_windowPtr =
      _lookup<
        ffi.NativeFunction<
          uint_t Function(ffi.Pointer<fvec_t>, ffi.Pointer<char_t>)
        >
      >('fvec_set_window');
  late final _fvec_set_window = _fvec_set_windowPtr
      .asFunction<int Function(ffi.Pointer<fvec_t>, ffi.Pointer<char_t>)>();

  /// compute the principal argument
  ///
  /// This function maps the input phase to its corresponding value wrapped in the
  /// range \f$ [-\pi, \pi] \f$.
  ///
  /// \param phase unwrapped phase to map to the unit circle
  ///
  /// \return equivalent phase wrapped to the unit circle
  double aubio_unwrap2pi(double phase) {
    return _aubio_unwrap2pi(phase);
  }

  late final _aubio_unwrap2piPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(smpl_t)>>('aubio_unwrap2pi');
  late final _aubio_unwrap2pi = _aubio_unwrap2piPtr
      .asFunction<double Function(double)>();

  /// convert frequency bin to midi value
  double aubio_bintomidi(double bin, double samplerate, double fftsize) {
    return _aubio_bintomidi(bin, samplerate, fftsize);
  }

  late final _aubio_bintomidiPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(smpl_t, smpl_t, smpl_t)>>(
        'aubio_bintomidi',
      );
  late final _aubio_bintomidi = _aubio_bintomidiPtr
      .asFunction<double Function(double, double, double)>();

  /// convert midi value to frequency bin
  double aubio_miditobin(double midi, double samplerate, double fftsize) {
    return _aubio_miditobin(midi, samplerate, fftsize);
  }

  late final _aubio_miditobinPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(smpl_t, smpl_t, smpl_t)>>(
        'aubio_miditobin',
      );
  late final _aubio_miditobin = _aubio_miditobinPtr
      .asFunction<double Function(double, double, double)>();

  /// convert frequency bin to frequency (Hz)
  double aubio_bintofreq(double bin, double samplerate, double fftsize) {
    return _aubio_bintofreq(bin, samplerate, fftsize);
  }

  late final _aubio_bintofreqPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(smpl_t, smpl_t, smpl_t)>>(
        'aubio_bintofreq',
      );
  late final _aubio_bintofreq = _aubio_bintofreqPtr
      .asFunction<double Function(double, double, double)>();

  /// convert frequency (Hz) to frequency bin
  double aubio_freqtobin(double freq, double samplerate, double fftsize) {
    return _aubio_freqtobin(freq, samplerate, fftsize);
  }

  late final _aubio_freqtobinPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(smpl_t, smpl_t, smpl_t)>>(
        'aubio_freqtobin',
      );
  late final _aubio_freqtobin = _aubio_freqtobinPtr
      .asFunction<double Function(double, double, double)>();

  /// convert frequency (Hz) to mel
  ///
  /// \param freq input frequency, in Hz
  ///
  /// \return output mel
  ///
  /// Converts a scalar from the frequency domain to the mel scale using Slaney
  /// Auditory Toolbox's implementation:
  ///
  /// If \f$ f < 1000 \f$, \f$ m = 3 f / 200 \f$.
  ///
  /// If \f$ f >= 1000 \f$, \f$ m = 1000 + 27 \frac{{ln}(f) - ln(1000))}
  /// {{ln}(6400) - ln(1000)}
  /// \f$
  ///
  /// See also
  /// --------
  ///
  /// aubio_meltohz(), aubio_hztomel_htk().
  double aubio_hztomel(double freq) {
    return _aubio_hztomel(freq);
  }

  late final _aubio_hztomelPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(smpl_t)>>('aubio_hztomel');
  late final _aubio_hztomel = _aubio_hztomelPtr
      .asFunction<double Function(double)>();

  /// convert mel to frequency (Hz)
  ///
  /// \param mel input mel
  ///
  /// \return output frequency, in Hz
  ///
  /// Converts a scalar from the mel scale to the frequency domain using Slaney
  /// Auditory Toolbox's implementation:
  ///
  /// If \f$ f < 1000 \f$, \f$ f = 200 m/3 \f$.
  ///
  /// If \f$ f \geq 1000 \f$, \f$ f = 1000 + \left(\frac{6400}{1000}\right)
  /// ^{\frac{m - 1000}{27}} \f$
  ///
  /// See also
  /// --------
  ///
  /// aubio_hztomel(), aubio_meltohz_htk().
  ///
  /// References
  /// ----------
  ///
  /// Malcolm Slaney, *Auditory Toolbox Version 2, Technical Report #1998-010*
  /// https://engineering.purdue.edu/~malcolm/interval/1998-010/
  double aubio_meltohz(double mel) {
    return _aubio_meltohz(mel);
  }

  late final _aubio_meltohzPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(smpl_t)>>('aubio_meltohz');
  late final _aubio_meltohz = _aubio_meltohzPtr
      .asFunction<double Function(double)>();

  /// convert frequency (Hz) to mel
  ///
  /// \param freq input frequency, in Hz
  ///
  /// \return output mel
  ///
  /// Converts a scalar from the frequency domain to the mel scale, using the
  /// equation defined by O'Shaughnessy, as implemented in the HTK speech
  /// recognition toolkit:
  ///
  /// \f$ m = 1127 + ln(1 + \frac{f}{700}) \f$
  ///
  /// See also
  /// --------
  ///
  /// aubio_meltohz_htk(), aubio_hztomel().
  ///
  /// References
  /// ----------
  ///
  /// Douglas O'Shaughnessy (1987). *Speech communication: human and machine*.
  /// Addison-Wesley. p. 150. ISBN 978-0-201-16520-3.
  ///
  /// HTK Speech Recognition Toolkit: http://htk.eng.cam.ac.uk/
  double aubio_hztomel_htk(double freq) {
    return _aubio_hztomel_htk(freq);
  }

  late final _aubio_hztomel_htkPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(smpl_t)>>('aubio_hztomel_htk');
  late final _aubio_hztomel_htk = _aubio_hztomel_htkPtr
      .asFunction<double Function(double)>();

  /// convert mel to frequency (Hz)
  ///
  /// \param mel input mel
  ///
  /// \return output frequency, in Hz
  ///
  /// Converts a scalar from the mel scale to the frequency domain, using the
  /// equation defined by O'Shaughnessy, as implemented in the HTK speech
  /// recognition toolkit:
  ///
  /// \f$ f = 700 * {e}^\left(\frac{f}{1127} - 1\right) \f$
  ///
  /// See also
  /// --------
  ///
  /// aubio_hztomel_htk(), aubio_meltohz().
  double aubio_meltohz_htk(double mel) {
    return _aubio_meltohz_htk(mel);
  }

  late final _aubio_meltohz_htkPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(smpl_t)>>('aubio_meltohz_htk');
  late final _aubio_meltohz_htk = _aubio_meltohz_htkPtr
      .asFunction<double Function(double)>();

  /// convert frequency (Hz) to midi value (0-128)
  double aubio_freqtomidi(double freq) {
    return _aubio_freqtomidi(freq);
  }

  late final _aubio_freqtomidiPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(smpl_t)>>('aubio_freqtomidi');
  late final _aubio_freqtomidi = _aubio_freqtomidiPtr
      .asFunction<double Function(double)>();

  /// convert midi value (0-128) to frequency (Hz)
  double aubio_miditofreq(double midi) {
    return _aubio_miditofreq(midi);
  }

  late final _aubio_miditofreqPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(smpl_t)>>('aubio_miditofreq');
  late final _aubio_miditofreq = _aubio_miditofreqPtr
      .asFunction<double Function(double)>();

  /// clean up cached memory at the end of program
  ///
  /// This function should be used at the end of programs to purge all cached
  /// memory. So far it is only useful to clean FFTW's cache.
  void aubio_cleanup() {
    return _aubio_cleanup();
  }

  late final _aubio_cleanupPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('aubio_cleanup');
  late final _aubio_cleanup = _aubio_cleanupPtr.asFunction<void Function()>();

  /// zero-crossing rate (ZCR)
  ///
  /// The zero-crossing rate is the number of times a signal changes sign,
  /// divided by the length of this signal.
  ///
  /// \param v vector to compute ZCR from
  ///
  /// \return zero-crossing rate of v
  double aubio_zero_crossing_rate(ffi.Pointer<fvec_t> v) {
    return _aubio_zero_crossing_rate(v);
  }

  late final _aubio_zero_crossing_ratePtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<fvec_t>)>>(
        'aubio_zero_crossing_rate',
      );
  late final _aubio_zero_crossing_rate = _aubio_zero_crossing_ratePtr
      .asFunction<double Function(ffi.Pointer<fvec_t>)>();

  /// compute sound level on a linear scale
  ///
  /// This gives the average of the square amplitudes.
  ///
  /// \param v vector to compute level from
  ///
  /// \return level of v
  double aubio_level_lin(ffi.Pointer<fvec_t> v) {
    return _aubio_level_lin(v);
  }

  late final _aubio_level_linPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<fvec_t>)>>(
        'aubio_level_lin',
      );
  late final _aubio_level_lin = _aubio_level_linPtr
      .asFunction<double Function(ffi.Pointer<fvec_t>)>();

  /// compute sound pressure level (SPL) in dB
  ///
  /// This quantity is often wrongly called 'loudness'.
  ///
  /// This gives ten times the log10 of the average of the square amplitudes.
  ///
  /// \param v vector to compute dB SPL from
  ///
  /// \return level of v in dB SPL
  double aubio_db_spl(ffi.Pointer<fvec_t> v) {
    return _aubio_db_spl(v);
  }

  late final _aubio_db_splPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<fvec_t>)>>(
        'aubio_db_spl',
      );
  late final _aubio_db_spl = _aubio_db_splPtr
      .asFunction<double Function(ffi.Pointer<fvec_t>)>();

  /// check if buffer level in dB SPL is under a given threshold
  ///
  /// \param v vector to get level from
  /// \param threshold threshold in dB SPL
  ///
  /// \return 1 if level is under the given threshold, 0 otherwise
  int aubio_silence_detection(ffi.Pointer<fvec_t> v, double threshold) {
    return _aubio_silence_detection(v, threshold);
  }

  late final _aubio_silence_detectionPtr =
      _lookup<ffi.NativeFunction<uint_t Function(ffi.Pointer<fvec_t>, smpl_t)>>(
        'aubio_silence_detection',
      );
  late final _aubio_silence_detection = _aubio_silence_detectionPtr
      .asFunction<int Function(ffi.Pointer<fvec_t>, double)>();

  /// get buffer level if level >= threshold, 1. otherwise
  ///
  /// \param v vector to get level from
  /// \param threshold threshold in dB SPL
  ///
  /// \return level in dB SPL if level >= threshold, 1. otherwise
  double aubio_level_detection(ffi.Pointer<fvec_t> v, double threshold) {
    return _aubio_level_detection(v, threshold);
  }

  late final _aubio_level_detectionPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<fvec_t>, smpl_t)>>(
        'aubio_level_detection',
      );
  late final _aubio_level_detection = _aubio_level_detectionPtr
      .asFunction<double Function(ffi.Pointer<fvec_t>, double)>();

  /// clamp the values of a vector within the range [-abs(max), abs(max)]
  ///
  /// \param in vector to clamp
  /// \param absmax maximum value over which input vector elements should be clamped
  void fvec_clamp(ffi.Pointer<fvec_t> in$, double absmax) {
    return _fvec_clamp(in$, absmax);
  }

  late final _fvec_clampPtr =
      _lookup<
        ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>, smpl_t)>
      >('fvec_clamp');
  late final _fvec_clamp = _fvec_clampPtr
      .asFunction<void Function(ffi.Pointer<fvec_t>, double)>();

  /// compute \f$e^x\f$ of each vector elements
  ///
  /// \param s vector to modify
  void fvec_exp(ffi.Pointer<fvec_t> s) {
    return _fvec_exp(s);
  }

  late final _fvec_expPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>)>>(
        'fvec_exp',
      );
  late final _fvec_exp = _fvec_expPtr
      .asFunction<void Function(ffi.Pointer<fvec_t>)>();

  /// compute \f$cos(x)\f$ of each vector elements
  ///
  /// \param s vector to modify
  void fvec_cos(ffi.Pointer<fvec_t> s) {
    return _fvec_cos(s);
  }

  late final _fvec_cosPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>)>>(
        'fvec_cos',
      );
  late final _fvec_cos = _fvec_cosPtr
      .asFunction<void Function(ffi.Pointer<fvec_t>)>();

  /// compute \f$sin(x)\f$ of each vector elements
  ///
  /// \param s vector to modify
  void fvec_sin(ffi.Pointer<fvec_t> s) {
    return _fvec_sin(s);
  }

  late final _fvec_sinPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>)>>(
        'fvec_sin',
      );
  late final _fvec_sin = _fvec_sinPtr
      .asFunction<void Function(ffi.Pointer<fvec_t>)>();

  /// compute the \f$abs(x)\f$ of each vector elements
  ///
  /// \param s vector to modify
  void fvec_abs(ffi.Pointer<fvec_t> s) {
    return _fvec_abs(s);
  }

  late final _fvec_absPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>)>>(
        'fvec_abs',
      );
  late final _fvec_abs = _fvec_absPtr
      .asFunction<void Function(ffi.Pointer<fvec_t>)>();

  /// compute the \f$sqrt(x)\f$ of each vector elements
  ///
  /// \param s vector to modify
  void fvec_sqrt(ffi.Pointer<fvec_t> s) {
    return _fvec_sqrt(s);
  }

  late final _fvec_sqrtPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>)>>(
        'fvec_sqrt',
      );
  late final _fvec_sqrt = _fvec_sqrtPtr
      .asFunction<void Function(ffi.Pointer<fvec_t>)>();

  /// compute the \f$log10(x)\f$ of each vector elements
  ///
  /// \param s vector to modify
  void fvec_log10(ffi.Pointer<fvec_t> s) {
    return _fvec_log10(s);
  }

  late final _fvec_log10Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>)>>(
        'fvec_log10',
      );
  late final _fvec_log10 = _fvec_log10Ptr
      .asFunction<void Function(ffi.Pointer<fvec_t>)>();

  /// compute the \f$log(x)\f$ of each vector elements
  ///
  /// \param s vector to modify
  void fvec_log(ffi.Pointer<fvec_t> s) {
    return _fvec_log(s);
  }

  late final _fvec_logPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>)>>(
        'fvec_log',
      );
  late final _fvec_log = _fvec_logPtr
      .asFunction<void Function(ffi.Pointer<fvec_t>)>();

  /// compute the \f$floor(x)\f$ of each vector elements
  ///
  /// \param s vector to modify
  void fvec_floor(ffi.Pointer<fvec_t> s) {
    return _fvec_floor(s);
  }

  late final _fvec_floorPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>)>>(
        'fvec_floor',
      );
  late final _fvec_floor = _fvec_floorPtr
      .asFunction<void Function(ffi.Pointer<fvec_t>)>();

  /// compute the \f$ceil(x)\f$ of each vector elements
  ///
  /// \param s vector to modify
  void fvec_ceil(ffi.Pointer<fvec_t> s) {
    return _fvec_ceil(s);
  }

  late final _fvec_ceilPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>)>>(
        'fvec_ceil',
      );
  late final _fvec_ceil = _fvec_ceilPtr
      .asFunction<void Function(ffi.Pointer<fvec_t>)>();

  /// compute the \f$round(x)\f$ of each vector elements
  ///
  /// \param s vector to modify
  void fvec_round(ffi.Pointer<fvec_t> s) {
    return _fvec_round(s);
  }

  late final _fvec_roundPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>)>>(
        'fvec_round',
      );
  late final _fvec_round = _fvec_roundPtr
      .asFunction<void Function(ffi.Pointer<fvec_t>)>();

  /// raise each vector elements to the power pow
  ///
  /// \param s vector to modify
  /// \param pow power to raise to
  void fvec_pow(ffi.Pointer<fvec_t> s, double pow) {
    return _fvec_pow(s, pow);
  }

  late final _fvec_powPtr =
      _lookup<
        ffi.NativeFunction<ffi.Void Function(ffi.Pointer<fvec_t>, smpl_t)>
      >('fvec_pow');
  late final _fvec_pow = _fvec_powPtr
      .asFunction<void Function(ffi.Pointer<fvec_t>, double)>();

  /// create resampler object
  ///
  /// \param ratio output_sample_rate / input_sample_rate
  /// \param type libsamplerate resampling type, see http://www.mega-nerd.com/SRC/api_misc.html#Converters
  ffi.Pointer<aubio_resampler_t> new_aubio_resampler(double ratio, int type) {
    return _new_aubio_resampler(ratio, type);
  }

  late final _new_aubio_resamplerPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<aubio_resampler_t> Function(smpl_t, uint_t)
        >
      >('new_aubio_resampler');
  late final _new_aubio_resampler = _new_aubio_resamplerPtr
      .asFunction<ffi.Pointer<aubio_resampler_t> Function(double, int)>();

  /// delete resampler object
  void del_aubio_resampler(ffi.Pointer<aubio_resampler_t> s) {
    return _del_aubio_resampler(s);
  }

  late final _del_aubio_resamplerPtr =
      _lookup<
        ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aubio_resampler_t>)>
      >('del_aubio_resampler');
  late final _del_aubio_resampler = _del_aubio_resamplerPtr
      .asFunction<void Function(ffi.Pointer<aubio_resampler_t>)>();

  /// resample input in output
  ///
  /// \param s resampler object
  /// \param input input buffer of size N
  /// \param output output buffer of size N*ratio
  void aubio_resampler_do(
    ffi.Pointer<aubio_resampler_t> s,
    ffi.Pointer<fvec_t> input,
    ffi.Pointer<fvec_t> output,
  ) {
    return _aubio_resampler_do(s, input, output);
  }

  late final _aubio_resampler_doPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<aubio_resampler_t>,
            ffi.Pointer<fvec_t>,
            ffi.Pointer<fvec_t>,
          )
        >
      >('aubio_resampler_do');
  late final _aubio_resampler_do = _aubio_resampler_doPtr
      .asFunction<
        void Function(
          ffi.Pointer<aubio_resampler_t>,
          ffi.Pointer<fvec_t>,
          ffi.Pointer<fvec_t>,
        )
      >();

  /// filter input vector (in-place)
  ///
  /// \param f filter object as returned by new_aubio_filter()
  /// \param in input vector to filter
  void aubio_filter_do(ffi.Pointer<aubio_filter_t> f, ffi.Pointer<fvec_t> in$) {
    return _aubio_filter_do(f, in$);
  }

  late final _aubio_filter_doPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aubio_filter_t>, ffi.Pointer<fvec_t>)
        >
      >('aubio_filter_do');
  late final _aubio_filter_do = _aubio_filter_doPtr
      .asFunction<
        void Function(ffi.Pointer<aubio_filter_t>, ffi.Pointer<fvec_t>)
      >();

  /// filter input vector (out-of-place)
  ///
  /// \param f filter object as returned by new_aubio_filter()
  /// \param in input vector to filter
  /// \param out output vector to store filtered input
  void aubio_filter_do_outplace(
    ffi.Pointer<aubio_filter_t> f,
    ffi.Pointer<fvec_t> in$,
    ffi.Pointer<fvec_t> out,
  ) {
    return _aubio_filter_do_outplace(f, in$, out);
  }

  late final _aubio_filter_do_outplacePtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<aubio_filter_t>,
            ffi.Pointer<fvec_t>,
            ffi.Pointer<fvec_t>,
          )
        >
      >('aubio_filter_do_outplace');
  late final _aubio_filter_do_outplace = _aubio_filter_do_outplacePtr
      .asFunction<
        void Function(
          ffi.Pointer<aubio_filter_t>,
          ffi.Pointer<fvec_t>,
          ffi.Pointer<fvec_t>,
        )
      >();

  /// filter input vector forward and backward
  ///
  /// \param f ::aubio_filter_t object as returned by new_aubio_filter()
  /// \param in ::fvec_t input vector to filter
  /// \param tmp memory space to use for computation
  void aubio_filter_do_filtfilt(
    ffi.Pointer<aubio_filter_t> f,
    ffi.Pointer<fvec_t> in$,
    ffi.Pointer<fvec_t> tmp,
  ) {
    return _aubio_filter_do_filtfilt(f, in$, tmp);
  }

  late final _aubio_filter_do_filtfiltPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<aubio_filter_t>,
            ffi.Pointer<fvec_t>,
            ffi.Pointer<fvec_t>,
          )
        >
      >('aubio_filter_do_filtfilt');
  late final _aubio_filter_do_filtfilt = _aubio_filter_do_filtfiltPtr
      .asFunction<
        void Function(
          ffi.Pointer<aubio_filter_t>,
          ffi.Pointer<fvec_t>,
          ffi.Pointer<fvec_t>,
        )
      >();

  /// returns a pointer to feedback coefficients \f$ a_i \f$
  ///
  /// \param f filter object to get parameters from
  ///
  /// \return a pointer to the \f$ a_0 ... a_i ... a_P \f$ coefficients
  ffi.Pointer<lvec_t> aubio_filter_get_feedback(ffi.Pointer<aubio_filter_t> f) {
    return _aubio_filter_get_feedback(f);
  }

  late final _aubio_filter_get_feedbackPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<lvec_t> Function(ffi.Pointer<aubio_filter_t>)
        >
      >('aubio_filter_get_feedback');
  late final _aubio_filter_get_feedback = _aubio_filter_get_feedbackPtr
      .asFunction<ffi.Pointer<lvec_t> Function(ffi.Pointer<aubio_filter_t>)>();

  /// returns a pointer to feedforward coefficients \f$ b_i \f$
  ///
  /// \param f filter object to get coefficients from
  ///
  /// \return a pointer to the \f$ b_0 ... b_i ... b_P \f$ coefficients
  ffi.Pointer<lvec_t> aubio_filter_get_feedforward(
    ffi.Pointer<aubio_filter_t> f,
  ) {
    return _aubio_filter_get_feedforward(f);
  }

  late final _aubio_filter_get_feedforwardPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<lvec_t> Function(ffi.Pointer<aubio_filter_t>)
        >
      >('aubio_filter_get_feedforward');
  late final _aubio_filter_get_feedforward = _aubio_filter_get_feedforwardPtr
      .asFunction<ffi.Pointer<lvec_t> Function(ffi.Pointer<aubio_filter_t>)>();

  /// get order of the filter
  ///
  /// \param f filter to get order from
  ///
  /// \return the order of the filter
  int aubio_filter_get_order(ffi.Pointer<aubio_filter_t> f) {
    return _aubio_filter_get_order(f);
  }

  late final _aubio_filter_get_orderPtr =
      _lookup<ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_filter_t>)>>(
        'aubio_filter_get_order',
      );
  late final _aubio_filter_get_order = _aubio_filter_get_orderPtr
      .asFunction<int Function(ffi.Pointer<aubio_filter_t>)>();

  /// get sampling rate of the filter
  ///
  /// \param f filter to get sampling rate from
  ///
  /// \return the sampling rate of the filter, in Hz
  int aubio_filter_get_samplerate(ffi.Pointer<aubio_filter_t> f) {
    return _aubio_filter_get_samplerate(f);
  }

  late final _aubio_filter_get_sampleratePtr =
      _lookup<ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_filter_t>)>>(
        'aubio_filter_get_samplerate',
      );
  late final _aubio_filter_get_samplerate = _aubio_filter_get_sampleratePtr
      .asFunction<int Function(ffi.Pointer<aubio_filter_t>)>();

  /// get sampling rate of the filter
  ///
  /// \param f filter to get sampling rate from
  /// \param samplerate sample rate to set the filter to
  ///
  /// \return the sampling rate of the filter, in Hz
  int aubio_filter_set_samplerate(
    ffi.Pointer<aubio_filter_t> f,
    int samplerate,
  ) {
    return _aubio_filter_set_samplerate(f, samplerate);
  }

  late final _aubio_filter_set_sampleratePtr =
      _lookup<
        ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_filter_t>, uint_t)>
      >('aubio_filter_set_samplerate');
  late final _aubio_filter_set_samplerate = _aubio_filter_set_sampleratePtr
      .asFunction<int Function(ffi.Pointer<aubio_filter_t>, int)>();

  /// reset filter memory
  ///
  /// \param f filter object as returned by new_aubio_filter()
  void aubio_filter_do_reset(ffi.Pointer<aubio_filter_t> f) {
    return _aubio_filter_do_reset(f);
  }

  late final _aubio_filter_do_resetPtr =
      _lookup<
        ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aubio_filter_t>)>
      >('aubio_filter_do_reset');
  late final _aubio_filter_do_reset = _aubio_filter_do_resetPtr
      .asFunction<void Function(ffi.Pointer<aubio_filter_t>)>();

  /// create new filter object
  ///
  /// This function creates a new ::aubio_filter_t object, given the order of the
  /// filter.
  ///
  /// \param order order of the filter (number of coefficients)
  ///
  /// \return the newly created filter object
  ffi.Pointer<aubio_filter_t> new_aubio_filter(int order) {
    return _new_aubio_filter(order);
  }

  late final _new_aubio_filterPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<aubio_filter_t> Function(uint_t)>>(
        'new_aubio_filter',
      );
  late final _new_aubio_filter = _new_aubio_filterPtr
      .asFunction<ffi.Pointer<aubio_filter_t> Function(int)>();

  /// delete a filter object
  ///
  /// \param f filter object to delete
  void del_aubio_filter(ffi.Pointer<aubio_filter_t> f) {
    return _del_aubio_filter(f);
  }

  late final _del_aubio_filterPtr =
      _lookup<
        ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aubio_filter_t>)>
      >('del_aubio_filter');
  late final _del_aubio_filter = _del_aubio_filterPtr
      .asFunction<void Function(ffi.Pointer<aubio_filter_t>)>();

  /// set coefficients of a biquad filter
  ///
  /// \param f filter object as returned by new_aubio_filter()
  /// \param b0 forward filter coefficient
  /// \param b1 forward filter coefficient
  /// \param b2 forward filter coefficient
  /// \param a1 feedback filter coefficient
  /// \param a2 feedback filter coefficient
  int aubio_filter_set_biquad(
    ffi.Pointer<aubio_filter_t> f,
    double b0,
    double b1,
    double b2,
    double a1,
    double a2,
  ) {
    return _aubio_filter_set_biquad(f, b0, b1, b2, a1, a2);
  }

  late final _aubio_filter_set_biquadPtr =
      _lookup<
        ffi.NativeFunction<
          uint_t Function(
            ffi.Pointer<aubio_filter_t>,
            lsmp_t,
            lsmp_t,
            lsmp_t,
            lsmp_t,
            lsmp_t,
          )
        >
      >('aubio_filter_set_biquad');
  late final _aubio_filter_set_biquad = _aubio_filter_set_biquadPtr
      .asFunction<
        int Function(
          ffi.Pointer<aubio_filter_t>,
          double,
          double,
          double,
          double,
          double,
        )
      >();

  /// create biquad filter with `b0`, `b1`, `b2`, `a1`, `a2` coeffs
  ///
  /// \param b0 forward filter coefficient
  /// \param b1 forward filter coefficient
  /// \param b2 forward filter coefficient
  /// \param a1 feedback filter coefficient
  /// \param a2 feedback filter coefficient
  ffi.Pointer<aubio_filter_t> new_aubio_filter_biquad(
    double b0,
    double b1,
    double b2,
    double a1,
    double a2,
  ) {
    return _new_aubio_filter_biquad(b0, b1, b2, a1, a2);
  }

  late final _new_aubio_filter_biquadPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<aubio_filter_t> Function(
            lsmp_t,
            lsmp_t,
            lsmp_t,
            lsmp_t,
            lsmp_t,
          )
        >
      >('new_aubio_filter_biquad');
  late final _new_aubio_filter_biquad = _new_aubio_filter_biquadPtr
      .asFunction<
        ffi.Pointer<aubio_filter_t> Function(
          double,
          double,
          double,
          double,
          double,
        )
      >();

  /// create new A-design filter
  ///
  /// \param samplerate sampling frequency of the signal to filter. Should be one of
  /// 8000, 11025, 16000, 22050, 24000, 32000, 44100, 48000, 88200, 96000, and
  /// 192000 Hz
  ///
  /// \return a new filter object
  ffi.Pointer<aubio_filter_t> new_aubio_filter_a_weighting(int samplerate) {
    return _new_aubio_filter_a_weighting(samplerate);
  }

  late final _new_aubio_filter_a_weightingPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<aubio_filter_t> Function(uint_t)>>(
        'new_aubio_filter_a_weighting',
      );
  late final _new_aubio_filter_a_weighting = _new_aubio_filter_a_weightingPtr
      .asFunction<ffi.Pointer<aubio_filter_t> Function(int)>();

  /// set feedback and feedforward coefficients of a A-weighting filter
  ///
  /// \param f filter object to get coefficients from
  /// \param samplerate sampling frequency of the signal to filter. Should be one of
  /// 8000, 11025, 16000, 22050, 24000, 32000, 44100, 48000, 88200, 96000, and
  /// 192000 Hz
  int aubio_filter_set_a_weighting(
    ffi.Pointer<aubio_filter_t> f,
    int samplerate,
  ) {
    return _aubio_filter_set_a_weighting(f, samplerate);
  }

  late final _aubio_filter_set_a_weightingPtr =
      _lookup<
        ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_filter_t>, uint_t)>
      >('aubio_filter_set_a_weighting');
  late final _aubio_filter_set_a_weighting = _aubio_filter_set_a_weightingPtr
      .asFunction<int Function(ffi.Pointer<aubio_filter_t>, int)>();

  /// create new C-design filter
  ///
  /// \param samplerate sampling frequency of the signal to filter. Should be one of
  /// 8000, 11025, 16000, 22050, 24000, 32000, 44100, 48000, 88200, 96000, and
  /// 192000 Hz
  ///
  /// \return a new filter object
  ffi.Pointer<aubio_filter_t> new_aubio_filter_c_weighting(int samplerate) {
    return _new_aubio_filter_c_weighting(samplerate);
  }

  late final _new_aubio_filter_c_weightingPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<aubio_filter_t> Function(uint_t)>>(
        'new_aubio_filter_c_weighting',
      );
  late final _new_aubio_filter_c_weighting = _new_aubio_filter_c_weightingPtr
      .asFunction<ffi.Pointer<aubio_filter_t> Function(int)>();

  /// set feedback and feedforward coefficients of a C-weighting filter
  ///
  /// \param f filter object to get coefficients from
  /// \param samplerate sampling frequency of the signal to filter. Should be one of
  /// 8000, 11025, 16000, 22050, 24000, 32000, 44100, 48000, 88200, 96000, and
  /// 192000 Hz
  int aubio_filter_set_c_weighting(
    ffi.Pointer<aubio_filter_t> f,
    int samplerate,
  ) {
    return _aubio_filter_set_c_weighting(f, samplerate);
  }

  late final _aubio_filter_set_c_weightingPtr =
      _lookup<
        ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_filter_t>, uint_t)>
      >('aubio_filter_set_c_weighting');
  late final _aubio_filter_set_c_weighting = _aubio_filter_set_c_weightingPtr
      .asFunction<int Function(ffi.Pointer<aubio_filter_t>, int)>();

  /// create new FFT computation object
  ///
  /// \param size length of the FFT
  ffi.Pointer<aubio_fft_t> new_aubio_fft(int size) {
    return _new_aubio_fft(size);
  }

  late final _new_aubio_fftPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<aubio_fft_t> Function(uint_t)>>(
        'new_aubio_fft',
      );
  late final _new_aubio_fft = _new_aubio_fftPtr
      .asFunction<ffi.Pointer<aubio_fft_t> Function(int)>();

  /// delete FFT object
  ///
  /// \param s fft object as returned by new_aubio_fft
  void del_aubio_fft(ffi.Pointer<aubio_fft_t> s) {
    return _del_aubio_fft(s);
  }

  late final _del_aubio_fftPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aubio_fft_t>)>>(
        'del_aubio_fft',
      );
  late final _del_aubio_fft = _del_aubio_fftPtr
      .asFunction<void Function(ffi.Pointer<aubio_fft_t>)>();

  /// compute forward FFT
  ///
  /// \param s fft object as returned by new_aubio_fft
  /// \param input input signal
  /// \param spectrum output spectrum
  void aubio_fft_do(
    ffi.Pointer<aubio_fft_t> s,
    ffi.Pointer<fvec_t> input,
    ffi.Pointer<cvec_t> spectrum,
  ) {
    return _aubio_fft_do(s, input, spectrum);
  }

  late final _aubio_fft_doPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<aubio_fft_t>,
            ffi.Pointer<fvec_t>,
            ffi.Pointer<cvec_t>,
          )
        >
      >('aubio_fft_do');
  late final _aubio_fft_do = _aubio_fft_doPtr
      .asFunction<
        void Function(
          ffi.Pointer<aubio_fft_t>,
          ffi.Pointer<fvec_t>,
          ffi.Pointer<cvec_t>,
        )
      >();

  /// compute backward (inverse) FFT
  ///
  /// \param s fft object as returned by new_aubio_fft
  /// \param spectrum input spectrum
  /// \param output output signal
  void aubio_fft_rdo(
    ffi.Pointer<aubio_fft_t> s,
    ffi.Pointer<cvec_t> spectrum,
    ffi.Pointer<fvec_t> output,
  ) {
    return _aubio_fft_rdo(s, spectrum, output);
  }

  late final _aubio_fft_rdoPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<aubio_fft_t>,
            ffi.Pointer<cvec_t>,
            ffi.Pointer<fvec_t>,
          )
        >
      >('aubio_fft_rdo');
  late final _aubio_fft_rdo = _aubio_fft_rdoPtr
      .asFunction<
        void Function(
          ffi.Pointer<aubio_fft_t>,
          ffi.Pointer<cvec_t>,
          ffi.Pointer<fvec_t>,
        )
      >();

  /// compute forward FFT
  ///
  /// \param s fft object as returned by new_aubio_fft
  /// \param input real input signal
  /// \param compspec complex output fft real/imag
  void aubio_fft_do_complex(
    ffi.Pointer<aubio_fft_t> s,
    ffi.Pointer<fvec_t> input,
    ffi.Pointer<fvec_t> compspec,
  ) {
    return _aubio_fft_do_complex(s, input, compspec);
  }

  late final _aubio_fft_do_complexPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<aubio_fft_t>,
            ffi.Pointer<fvec_t>,
            ffi.Pointer<fvec_t>,
          )
        >
      >('aubio_fft_do_complex');
  late final _aubio_fft_do_complex = _aubio_fft_do_complexPtr
      .asFunction<
        void Function(
          ffi.Pointer<aubio_fft_t>,
          ffi.Pointer<fvec_t>,
          ffi.Pointer<fvec_t>,
        )
      >();

  /// compute backward (inverse) FFT from real/imag
  ///
  /// \param s fft object as returned by new_aubio_fft
  /// \param compspec real/imag input fft array
  /// \param output real output array
  void aubio_fft_rdo_complex(
    ffi.Pointer<aubio_fft_t> s,
    ffi.Pointer<fvec_t> compspec,
    ffi.Pointer<fvec_t> output,
  ) {
    return _aubio_fft_rdo_complex(s, compspec, output);
  }

  late final _aubio_fft_rdo_complexPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<aubio_fft_t>,
            ffi.Pointer<fvec_t>,
            ffi.Pointer<fvec_t>,
          )
        >
      >('aubio_fft_rdo_complex');
  late final _aubio_fft_rdo_complex = _aubio_fft_rdo_complexPtr
      .asFunction<
        void Function(
          ffi.Pointer<aubio_fft_t>,
          ffi.Pointer<fvec_t>,
          ffi.Pointer<fvec_t>,
        )
      >();

  /// convert real/imag spectrum to norm/phas spectrum
  ///
  /// \param compspec real/imag input fft array
  /// \param spectrum cvec norm/phas output array
  void aubio_fft_get_spectrum(
    ffi.Pointer<fvec_t> compspec,
    ffi.Pointer<cvec_t> spectrum,
  ) {
    return _aubio_fft_get_spectrum(compspec, spectrum);
  }

  late final _aubio_fft_get_spectrumPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<fvec_t>, ffi.Pointer<cvec_t>)
        >
      >('aubio_fft_get_spectrum');
  late final _aubio_fft_get_spectrum = _aubio_fft_get_spectrumPtr
      .asFunction<void Function(ffi.Pointer<fvec_t>, ffi.Pointer<cvec_t>)>();

  /// convert real/imag spectrum to norm/phas spectrum
  ///
  /// \param compspec real/imag input fft array
  /// \param spectrum cvec norm/phas output array
  void aubio_fft_get_realimag(
    ffi.Pointer<cvec_t> spectrum,
    ffi.Pointer<fvec_t> compspec,
  ) {
    return _aubio_fft_get_realimag(spectrum, compspec);
  }

  late final _aubio_fft_get_realimagPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<cvec_t>, ffi.Pointer<fvec_t>)
        >
      >('aubio_fft_get_realimag');
  late final _aubio_fft_get_realimag = _aubio_fft_get_realimagPtr
      .asFunction<void Function(ffi.Pointer<cvec_t>, ffi.Pointer<fvec_t>)>();

  /// compute phas spectrum from real/imag parts
  ///
  /// \param compspec real/imag input fft array
  /// \param spectrum cvec norm/phas output array
  void aubio_fft_get_phas(
    ffi.Pointer<fvec_t> compspec,
    ffi.Pointer<cvec_t> spectrum,
  ) {
    return _aubio_fft_get_phas(compspec, spectrum);
  }

  late final _aubio_fft_get_phasPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<fvec_t>, ffi.Pointer<cvec_t>)
        >
      >('aubio_fft_get_phas');
  late final _aubio_fft_get_phas = _aubio_fft_get_phasPtr
      .asFunction<void Function(ffi.Pointer<fvec_t>, ffi.Pointer<cvec_t>)>();

  /// compute imaginary part from the norm/phas cvec
  ///
  /// \param spectrum norm/phas input array
  /// \param compspec real/imag output fft array
  void aubio_fft_get_imag(
    ffi.Pointer<cvec_t> spectrum,
    ffi.Pointer<fvec_t> compspec,
  ) {
    return _aubio_fft_get_imag(spectrum, compspec);
  }

  late final _aubio_fft_get_imagPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<cvec_t>, ffi.Pointer<fvec_t>)
        >
      >('aubio_fft_get_imag');
  late final _aubio_fft_get_imag = _aubio_fft_get_imagPtr
      .asFunction<void Function(ffi.Pointer<cvec_t>, ffi.Pointer<fvec_t>)>();

  /// compute norm component from real/imag parts
  ///
  /// \param compspec real/imag input fft array
  /// \param spectrum cvec norm/phas output array
  void aubio_fft_get_norm(
    ffi.Pointer<fvec_t> compspec,
    ffi.Pointer<cvec_t> spectrum,
  ) {
    return _aubio_fft_get_norm(compspec, spectrum);
  }

  late final _aubio_fft_get_normPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<fvec_t>, ffi.Pointer<cvec_t>)
        >
      >('aubio_fft_get_norm');
  late final _aubio_fft_get_norm = _aubio_fft_get_normPtr
      .asFunction<void Function(ffi.Pointer<fvec_t>, ffi.Pointer<cvec_t>)>();

  /// compute real part from norm/phas components
  ///
  /// \param spectrum norm/phas input array
  /// \param compspec real/imag output fft array
  void aubio_fft_get_real(
    ffi.Pointer<cvec_t> spectrum,
    ffi.Pointer<fvec_t> compspec,
  ) {
    return _aubio_fft_get_real(spectrum, compspec);
  }

  late final _aubio_fft_get_realPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<cvec_t>, ffi.Pointer<fvec_t>)
        >
      >('aubio_fft_get_real');
  late final _aubio_fft_get_real = _aubio_fft_get_realPtr
      .asFunction<void Function(ffi.Pointer<cvec_t>, ffi.Pointer<fvec_t>)>();

  /// create new DCT computation object
  ///
  /// \param size length of the DCT
  ffi.Pointer<aubio_dct_t> new_aubio_dct(int size) {
    return _new_aubio_dct(size);
  }

  late final _new_aubio_dctPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<aubio_dct_t> Function(uint_t)>>(
        'new_aubio_dct',
      );
  late final _new_aubio_dct = _new_aubio_dctPtr
      .asFunction<ffi.Pointer<aubio_dct_t> Function(int)>();

  /// compute forward DCT
  ///
  /// \param s dct object as returned by new_aubio_dct
  /// \param input input signal
  /// \param dct_output transformed input array
  void aubio_dct_do(
    ffi.Pointer<aubio_dct_t> s,
    ffi.Pointer<fvec_t> input,
    ffi.Pointer<fvec_t> dct_output,
  ) {
    return _aubio_dct_do(s, input, dct_output);
  }

  late final _aubio_dct_doPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<aubio_dct_t>,
            ffi.Pointer<fvec_t>,
            ffi.Pointer<fvec_t>,
          )
        >
      >('aubio_dct_do');
  late final _aubio_dct_do = _aubio_dct_doPtr
      .asFunction<
        void Function(
          ffi.Pointer<aubio_dct_t>,
          ffi.Pointer<fvec_t>,
          ffi.Pointer<fvec_t>,
        )
      >();

  /// compute backward DCT
  ///
  /// \param s dct object as returned by new_aubio_dct
  /// \param input input signal
  /// \param idct_output transformed input array
  void aubio_dct_rdo(
    ffi.Pointer<aubio_dct_t> s,
    ffi.Pointer<fvec_t> input,
    ffi.Pointer<fvec_t> idct_output,
  ) {
    return _aubio_dct_rdo(s, input, idct_output);
  }

  late final _aubio_dct_rdoPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<aubio_dct_t>,
            ffi.Pointer<fvec_t>,
            ffi.Pointer<fvec_t>,
          )
        >
      >('aubio_dct_rdo');
  late final _aubio_dct_rdo = _aubio_dct_rdoPtr
      .asFunction<
        void Function(
          ffi.Pointer<aubio_dct_t>,
          ffi.Pointer<fvec_t>,
          ffi.Pointer<fvec_t>,
        )
      >();

  /// delete DCT object
  ///
  /// \param s dct object as returned by new_aubio_dct
  void del_aubio_dct(ffi.Pointer<aubio_dct_t> s) {
    return _del_aubio_dct(s);
  }

  late final _del_aubio_dctPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aubio_dct_t>)>>(
        'del_aubio_dct',
      );
  late final _del_aubio_dct = _del_aubio_dctPtr
      .asFunction<void Function(ffi.Pointer<aubio_dct_t>)>();

  /// create phase vocoder object
  ///
  /// \param win_s size of analysis buffer (and length the FFT transform)
  /// \param hop_s step size between two consecutive analysis
  ffi.Pointer<aubio_pvoc_t> new_aubio_pvoc(int win_s, int hop_s) {
    return _new_aubio_pvoc(win_s, hop_s);
  }

  late final _new_aubio_pvocPtr =
      _lookup<
        ffi.NativeFunction<ffi.Pointer<aubio_pvoc_t> Function(uint_t, uint_t)>
      >('new_aubio_pvoc');
  late final _new_aubio_pvoc = _new_aubio_pvocPtr
      .asFunction<ffi.Pointer<aubio_pvoc_t> Function(int, int)>();

  /// delete phase vocoder object
  ///
  /// \param pv phase vocoder object as returned by new_aubio_pvoc
  void del_aubio_pvoc(ffi.Pointer<aubio_pvoc_t> pv) {
    return _del_aubio_pvoc(pv);
  }

  late final _del_aubio_pvocPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aubio_pvoc_t>)>>(
        'del_aubio_pvoc',
      );
  late final _del_aubio_pvoc = _del_aubio_pvocPtr
      .asFunction<void Function(ffi.Pointer<aubio_pvoc_t>)>();

  /// compute spectral frame
  ///
  /// This function accepts an input vector of size [hop_s]. The
  /// analysis buffer is rotated and filled with the new data. After windowing of
  /// this signal window, the Fourier transform is computed and returned in
  /// fftgrain as two vectors, magnitude and phase.
  ///
  /// \param pv phase vocoder object as returned by new_aubio_pvoc
  /// \param in new input signal (hop_s long)
  /// \param fftgrain output spectral frame
  void aubio_pvoc_do(
    ffi.Pointer<aubio_pvoc_t> pv,
    ffi.Pointer<fvec_t> in$,
    ffi.Pointer<cvec_t> fftgrain,
  ) {
    return _aubio_pvoc_do(pv, in$, fftgrain);
  }

  late final _aubio_pvoc_doPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<aubio_pvoc_t>,
            ffi.Pointer<fvec_t>,
            ffi.Pointer<cvec_t>,
          )
        >
      >('aubio_pvoc_do');
  late final _aubio_pvoc_do = _aubio_pvoc_doPtr
      .asFunction<
        void Function(
          ffi.Pointer<aubio_pvoc_t>,
          ffi.Pointer<fvec_t>,
          ffi.Pointer<cvec_t>,
        )
      >();

  /// compute signal from spectral frame
  ///
  /// This function takes an input spectral frame fftgrain of size
  /// [buf_s] and computes its inverse Fourier transform. Overlap-add
  /// synthesis is then computed using the previously synthetised frames, and the
  /// output stored in out.
  ///
  /// \param pv phase vocoder object as returned by new_aubio_pvoc
  /// \param fftgrain input spectral frame
  /// \param out output signal (hop_s long)
  void aubio_pvoc_rdo(
    ffi.Pointer<aubio_pvoc_t> pv,
    ffi.Pointer<cvec_t> fftgrain,
    ffi.Pointer<fvec_t> out,
  ) {
    return _aubio_pvoc_rdo(pv, fftgrain, out);
  }

  late final _aubio_pvoc_rdoPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<aubio_pvoc_t>,
            ffi.Pointer<cvec_t>,
            ffi.Pointer<fvec_t>,
          )
        >
      >('aubio_pvoc_rdo');
  late final _aubio_pvoc_rdo = _aubio_pvoc_rdoPtr
      .asFunction<
        void Function(
          ffi.Pointer<aubio_pvoc_t>,
          ffi.Pointer<cvec_t>,
          ffi.Pointer<fvec_t>,
        )
      >();

  /// get window size
  ///
  /// \param pv phase vocoder to get the window size from
  int aubio_pvoc_get_win(ffi.Pointer<aubio_pvoc_t> pv) {
    return _aubio_pvoc_get_win(pv);
  }

  late final _aubio_pvoc_get_winPtr =
      _lookup<ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_pvoc_t>)>>(
        'aubio_pvoc_get_win',
      );
  late final _aubio_pvoc_get_win = _aubio_pvoc_get_winPtr
      .asFunction<int Function(ffi.Pointer<aubio_pvoc_t>)>();

  /// get hop size
  ///
  /// \param pv phase vocoder to get the hop size from
  int aubio_pvoc_get_hop(ffi.Pointer<aubio_pvoc_t> pv) {
    return _aubio_pvoc_get_hop(pv);
  }

  late final _aubio_pvoc_get_hopPtr =
      _lookup<ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_pvoc_t>)>>(
        'aubio_pvoc_get_hop',
      );
  late final _aubio_pvoc_get_hop = _aubio_pvoc_get_hopPtr
      .asFunction<int Function(ffi.Pointer<aubio_pvoc_t>)>();

  /// set window type
  ///
  /// \param pv phase vocoder to set the window type
  /// \param window_type a string representing a window
  ///
  /// \return 0 if successful, non-zero otherwise
  int aubio_pvoc_set_window(
    ffi.Pointer<aubio_pvoc_t> pv,
    ffi.Pointer<char_t> window_type,
  ) {
    return _aubio_pvoc_set_window(pv, window_type);
  }

  late final _aubio_pvoc_set_windowPtr =
      _lookup<
        ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_pvoc_t>, ffi.Pointer<char_t>)
        >
      >('aubio_pvoc_set_window');
  late final _aubio_pvoc_set_window = _aubio_pvoc_set_windowPtr
      .asFunction<
        int Function(ffi.Pointer<aubio_pvoc_t>, ffi.Pointer<char_t>)
      >();

  /// create filterbank object
  ///
  /// \param n_filters number of filters to create
  /// \param win_s size of analysis buffer (and length the FFT transform)
  ffi.Pointer<aubio_filterbank_t> new_aubio_filterbank(
    int n_filters,
    int win_s,
  ) {
    return _new_aubio_filterbank(n_filters, win_s);
  }

  late final _new_aubio_filterbankPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<aubio_filterbank_t> Function(uint_t, uint_t)
        >
      >('new_aubio_filterbank');
  late final _new_aubio_filterbank = _new_aubio_filterbankPtr
      .asFunction<ffi.Pointer<aubio_filterbank_t> Function(int, int)>();

  /// destroy filterbank object
  ///
  /// \param f filterbank object, as returned by new_aubio_filterbank()
  void del_aubio_filterbank(ffi.Pointer<aubio_filterbank_t> f) {
    return _del_aubio_filterbank(f);
  }

  late final _del_aubio_filterbankPtr =
      _lookup<
        ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aubio_filterbank_t>)>
      >('del_aubio_filterbank');
  late final _del_aubio_filterbank = _del_aubio_filterbankPtr
      .asFunction<void Function(ffi.Pointer<aubio_filterbank_t>)>();

  /// compute filterbank
  ///
  /// \param f filterbank object, as returned by new_aubio_filterbank()
  /// \param in input spectrum containing an input spectrum of length `win_s`
  /// \param out output vector containing the energy found in each band, `nfilt` output values
  void aubio_filterbank_do(
    ffi.Pointer<aubio_filterbank_t> f,
    ffi.Pointer<cvec_t> in$,
    ffi.Pointer<fvec_t> out,
  ) {
    return _aubio_filterbank_do(f, in$, out);
  }

  late final _aubio_filterbank_doPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<aubio_filterbank_t>,
            ffi.Pointer<cvec_t>,
            ffi.Pointer<fvec_t>,
          )
        >
      >('aubio_filterbank_do');
  late final _aubio_filterbank_do = _aubio_filterbank_doPtr
      .asFunction<
        void Function(
          ffi.Pointer<aubio_filterbank_t>,
          ffi.Pointer<cvec_t>,
          ffi.Pointer<fvec_t>,
        )
      >();

  /// return a pointer to the matrix object containing all filter coefficients
  ///
  /// \param f filterbank object, as returned by new_aubio_filterbank()
  ffi.Pointer<fmat_t> aubio_filterbank_get_coeffs(
    ffi.Pointer<aubio_filterbank_t> f,
  ) {
    return _aubio_filterbank_get_coeffs(f);
  }

  late final _aubio_filterbank_get_coeffsPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<fmat_t> Function(ffi.Pointer<aubio_filterbank_t>)
        >
      >('aubio_filterbank_get_coeffs');
  late final _aubio_filterbank_get_coeffs = _aubio_filterbank_get_coeffsPtr
      .asFunction<
        ffi.Pointer<fmat_t> Function(ffi.Pointer<aubio_filterbank_t>)
      >();

  /// copy filter coefficients to the filterbank
  ///
  /// \param f filterbank object, as returned by new_aubio_filterbank()
  /// \param filters filter bank coefficients to copy from
  int aubio_filterbank_set_coeffs(
    ffi.Pointer<aubio_filterbank_t> f,
    ffi.Pointer<fmat_t> filters,
  ) {
    return _aubio_filterbank_set_coeffs(f, filters);
  }

  late final _aubio_filterbank_set_coeffsPtr =
      _lookup<
        ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_filterbank_t>, ffi.Pointer<fmat_t>)
        >
      >('aubio_filterbank_set_coeffs');
  late final _aubio_filterbank_set_coeffs = _aubio_filterbank_set_coeffsPtr
      .asFunction<
        int Function(ffi.Pointer<aubio_filterbank_t>, ffi.Pointer<fmat_t>)
      >();

  /// set norm parameter
  ///
  /// \param f filterbank object, as returned by new_aubio_filterbank()
  /// \param norm `1` to norm the filters, `0` otherwise.
  ///
  /// If set to `0`, the filters will not be normalized. If set to `1`,
  /// each filter will be normalized to one. Defaults to `1`.
  ///
  /// This function should be called *before* setting the filters with one of
  /// aubio_filterbank_set_triangle_bands(), aubio_filterbank_set_mel_coeffs(),
  /// aubio_filterbank_set_mel_coeffs_htk(), or
  /// aubio_filterbank_set_mel_coeffs_slaney().
  int aubio_filterbank_set_norm(
    ffi.Pointer<aubio_filterbank_t> f,
    double norm,
  ) {
    return _aubio_filterbank_set_norm(f, norm);
  }

  late final _aubio_filterbank_set_normPtr =
      _lookup<
        ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_filterbank_t>, smpl_t)
        >
      >('aubio_filterbank_set_norm');
  late final _aubio_filterbank_set_norm = _aubio_filterbank_set_normPtr
      .asFunction<int Function(ffi.Pointer<aubio_filterbank_t>, double)>();

  /// get norm parameter
  ///
  /// \param f filterbank object, as returned by new_aubio_filterbank()
  /// \returns `1` if norm is set, `0` otherwise. Defaults to `1`.
  double aubio_filterbank_get_norm(ffi.Pointer<aubio_filterbank_t> f) {
    return _aubio_filterbank_get_norm(f);
  }

  late final _aubio_filterbank_get_normPtr =
      _lookup<
        ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_filterbank_t>)>
      >('aubio_filterbank_get_norm');
  late final _aubio_filterbank_get_norm = _aubio_filterbank_get_normPtr
      .asFunction<double Function(ffi.Pointer<aubio_filterbank_t>)>();

  /// set power parameter
  ///
  /// \param f filterbank object, as returned by new_aubio_filterbank()
  /// \param power Raise norm of the input spectrum norm to this power before
  /// computing filterbank.  Defaults to `1`.
  int aubio_filterbank_set_power(
    ffi.Pointer<aubio_filterbank_t> f,
    double power,
  ) {
    return _aubio_filterbank_set_power(f, power);
  }

  late final _aubio_filterbank_set_powerPtr =
      _lookup<
        ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_filterbank_t>, smpl_t)
        >
      >('aubio_filterbank_set_power');
  late final _aubio_filterbank_set_power = _aubio_filterbank_set_powerPtr
      .asFunction<int Function(ffi.Pointer<aubio_filterbank_t>, double)>();

  /// get power parameter
  ///
  /// \param f filterbank object, as returned by new_aubio_filterbank()
  /// \return current power parameter. Defaults to `1`.
  double aubio_filterbank_get_power(ffi.Pointer<aubio_filterbank_t> f) {
    return _aubio_filterbank_get_power(f);
  }

  late final _aubio_filterbank_get_powerPtr =
      _lookup<
        ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_filterbank_t>)>
      >('aubio_filterbank_get_power');
  late final _aubio_filterbank_get_power = _aubio_filterbank_get_powerPtr
      .asFunction<double Function(ffi.Pointer<aubio_filterbank_t>)>();

  /// filterbank initialization with triangular and overlapping bands
  ///
  /// \param fb filterbank object
  /// \param freqs arbitrary array of boundary frequencies
  /// \param samplerate audio sampling rate
  ///
  /// This function computes the coefficients of the filterbank based on the
  /// boundaries found in freqs, in Hz, and using triangular overlapping bands.
  int aubio_filterbank_set_triangle_bands(
    ffi.Pointer<aubio_filterbank_t> fb,
    ffi.Pointer<fvec_t> freqs,
    double samplerate,
  ) {
    return _aubio_filterbank_set_triangle_bands(fb, freqs, samplerate);
  }

  late final _aubio_filterbank_set_triangle_bandsPtr =
      _lookup<
        ffi.NativeFunction<
          uint_t Function(
            ffi.Pointer<aubio_filterbank_t>,
            ffi.Pointer<fvec_t>,
            smpl_t,
          )
        >
      >('aubio_filterbank_set_triangle_bands');
  late final _aubio_filterbank_set_triangle_bands =
      _aubio_filterbank_set_triangle_bandsPtr
          .asFunction<
            int Function(
              ffi.Pointer<aubio_filterbank_t>,
              ffi.Pointer<fvec_t>,
              double,
            )
          >();

  /// filterbank initialization for Mel filters using Slaney's coefficients
  ///
  /// \param fb filterbank object
  /// \param samplerate audio sampling rate, in Hz
  ///
  /// The filter coefficients are built to match exactly Malcolm Slaney's Auditory
  /// Toolbox implementation (see file mfcc.m). The number of filters should be 40.
  ///
  /// References
  /// ----------
  ///
  /// Malcolm Slaney, *Auditory Toolbox Version 2, Technical Report #1998-010*
  /// https://engineering.purdue.edu/~malcolm/interval/1998-010/
  int aubio_filterbank_set_mel_coeffs_slaney(
    ffi.Pointer<aubio_filterbank_t> fb,
    double samplerate,
  ) {
    return _aubio_filterbank_set_mel_coeffs_slaney(fb, samplerate);
  }

  late final _aubio_filterbank_set_mel_coeffs_slaneyPtr =
      _lookup<
        ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_filterbank_t>, smpl_t)
        >
      >('aubio_filterbank_set_mel_coeffs_slaney');
  late final _aubio_filterbank_set_mel_coeffs_slaney =
      _aubio_filterbank_set_mel_coeffs_slaneyPtr
          .asFunction<int Function(ffi.Pointer<aubio_filterbank_t>, double)>();

  /// Mel filterbank initialization
  ///
  /// \param fb filterbank object
  /// \param samplerate audio sampling rate
  /// \param fmin start frequency, in Hz
  /// \param fmax end frequency, in Hz
  ///
  /// The filterbank will be initialized with bands linearly spaced in the mel
  /// scale, from `fmin` to `fmax`.
  ///
  /// References
  /// ----------
  ///
  /// Malcolm Slaney, *Auditory Toolbox Version 2, Technical Report #1998-010*
  /// https://engineering.purdue.edu/~malcolm/interval/1998-010/
  int aubio_filterbank_set_mel_coeffs(
    ffi.Pointer<aubio_filterbank_t> fb,
    double samplerate,
    double fmin,
    double fmax,
  ) {
    return _aubio_filterbank_set_mel_coeffs(fb, samplerate, fmin, fmax);
  }

  late final _aubio_filterbank_set_mel_coeffsPtr =
      _lookup<
        ffi.NativeFunction<
          uint_t Function(
            ffi.Pointer<aubio_filterbank_t>,
            smpl_t,
            smpl_t,
            smpl_t,
          )
        >
      >('aubio_filterbank_set_mel_coeffs');
  late final _aubio_filterbank_set_mel_coeffs =
      _aubio_filterbank_set_mel_coeffsPtr
          .asFunction<
            int Function(
              ffi.Pointer<aubio_filterbank_t>,
              double,
              double,
              double,
            )
          >();

  /// Mel filterbank initialization
  ///
  /// \param fb filterbank object
  /// \param samplerate audio sampling rate
  /// \param fmin start frequency, in Hz
  /// \param fmax end frequency, in Hz
  ///
  /// The bank of filters will be initalized to to cover linearly spaced bands in
  /// the Htk mel scale, from `fmin` to `fmax`.
  ///
  /// References
  /// ----------
  ///
  /// Douglas O'Shaughnessy (1987). *Speech communication: human and machine*.
  /// Addison-Wesley. p. 150. ISBN 978-0-201-16520-3.
  ///
  /// HTK Speech Recognition Toolkit: http://htk.eng.cam.ac.uk/
  int aubio_filterbank_set_mel_coeffs_htk(
    ffi.Pointer<aubio_filterbank_t> fb,
    double samplerate,
    double fmin,
    double fmax,
  ) {
    return _aubio_filterbank_set_mel_coeffs_htk(fb, samplerate, fmin, fmax);
  }

  late final _aubio_filterbank_set_mel_coeffs_htkPtr =
      _lookup<
        ffi.NativeFunction<
          uint_t Function(
            ffi.Pointer<aubio_filterbank_t>,
            smpl_t,
            smpl_t,
            smpl_t,
          )
        >
      >('aubio_filterbank_set_mel_coeffs_htk');
  late final _aubio_filterbank_set_mel_coeffs_htk =
      _aubio_filterbank_set_mel_coeffs_htkPtr
          .asFunction<
            int Function(
              ffi.Pointer<aubio_filterbank_t>,
              double,
              double,
              double,
            )
          >();

  /// create mfcc object
  ///
  /// \param buf_size size of analysis buffer (and length the FFT transform)
  /// \param samplerate audio sampling rate
  /// \param n_coeffs number of desired coefficients
  /// \param n_filters number of desired filters
  ffi.Pointer<aubio_mfcc_t> new_aubio_mfcc(
    int buf_size,
    int n_filters,
    int n_coeffs,
    int samplerate,
  ) {
    return _new_aubio_mfcc(buf_size, n_filters, n_coeffs, samplerate);
  }

  late final _new_aubio_mfccPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<aubio_mfcc_t> Function(uint_t, uint_t, uint_t, uint_t)
        >
      >('new_aubio_mfcc');
  late final _new_aubio_mfcc = _new_aubio_mfccPtr
      .asFunction<ffi.Pointer<aubio_mfcc_t> Function(int, int, int, int)>();

  /// delete mfcc object
  ///
  /// \param mf mfcc object as returned by new_aubio_mfcc
  void del_aubio_mfcc(ffi.Pointer<aubio_mfcc_t> mf) {
    return _del_aubio_mfcc(mf);
  }

  late final _del_aubio_mfccPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aubio_mfcc_t>)>>(
        'del_aubio_mfcc',
      );
  late final _del_aubio_mfcc = _del_aubio_mfccPtr
      .asFunction<void Function(ffi.Pointer<aubio_mfcc_t>)>();

  /// mfcc object processing
  ///
  /// \param mf mfcc object as returned by new_aubio_mfcc
  /// \param in input spectrum (buf_size long)
  /// \param out output mel coefficients buffer (n_coeffs long)
  void aubio_mfcc_do(
    ffi.Pointer<aubio_mfcc_t> mf,
    ffi.Pointer<cvec_t> in$,
    ffi.Pointer<fvec_t> out,
  ) {
    return _aubio_mfcc_do(mf, in$, out);
  }

  late final _aubio_mfcc_doPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<aubio_mfcc_t>,
            ffi.Pointer<cvec_t>,
            ffi.Pointer<fvec_t>,
          )
        >
      >('aubio_mfcc_do');
  late final _aubio_mfcc_do = _aubio_mfcc_doPtr
      .asFunction<
        void Function(
          ffi.Pointer<aubio_mfcc_t>,
          ffi.Pointer<cvec_t>,
          ffi.Pointer<fvec_t>,
        )
      >();

  /// set power parameter
  ///
  /// \param mf mfcc object, as returned by new_aubio_mfcc()
  /// \param power Raise norm of the input spectrum norm to this power before
  /// computing filterbank.  Defaults to `1`.
  ///
  /// See aubio_filterbank_set_power().
  int aubio_mfcc_set_power(ffi.Pointer<aubio_mfcc_t> mf, double power) {
    return _aubio_mfcc_set_power(mf, power);
  }

  late final _aubio_mfcc_set_powerPtr =
      _lookup<
        ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_mfcc_t>, smpl_t)>
      >('aubio_mfcc_set_power');
  late final _aubio_mfcc_set_power = _aubio_mfcc_set_powerPtr
      .asFunction<int Function(ffi.Pointer<aubio_mfcc_t>, double)>();

  /// get power parameter
  ///
  /// \param mf mfcc object, as returned by new_aubio_mfcc()
  /// \return current power parameter. Defaults to `1`.
  ///
  /// See aubio_filterbank_get_power().
  double aubio_mfcc_get_power(ffi.Pointer<aubio_mfcc_t> mf) {
    return _aubio_mfcc_get_power(mf);
  }

  late final _aubio_mfcc_get_powerPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_mfcc_t>)>>(
        'aubio_mfcc_get_power',
      );
  late final _aubio_mfcc_get_power = _aubio_mfcc_get_powerPtr
      .asFunction<double Function(ffi.Pointer<aubio_mfcc_t>)>();

  /// set scaling parameter
  ///
  /// \param mf mfcc object, as returned by new_aubio_mfcc()
  /// \param scale Scaling value to apply.
  ///
  /// Scales the output of the filterbank after taking its logarithm and before
  /// computing the DCT. Defaults to `1`.
  int aubio_mfcc_set_scale(ffi.Pointer<aubio_mfcc_t> mf, double scale) {
    return _aubio_mfcc_set_scale(mf, scale);
  }

  late final _aubio_mfcc_set_scalePtr =
      _lookup<
        ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_mfcc_t>, smpl_t)>
      >('aubio_mfcc_set_scale');
  late final _aubio_mfcc_set_scale = _aubio_mfcc_set_scalePtr
      .asFunction<int Function(ffi.Pointer<aubio_mfcc_t>, double)>();

  /// get scaling parameter
  ///
  /// \param mf mfcc object, as returned by new_aubio_mfcc()
  /// \return current scaling parameter. Defaults to `1`.
  double aubio_mfcc_get_scale(ffi.Pointer<aubio_mfcc_t> mf) {
    return _aubio_mfcc_get_scale(mf);
  }

  late final _aubio_mfcc_get_scalePtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_mfcc_t>)>>(
        'aubio_mfcc_get_scale',
      );
  late final _aubio_mfcc_get_scale = _aubio_mfcc_get_scalePtr
      .asFunction<double Function(ffi.Pointer<aubio_mfcc_t>)>();

  /// Mel filterbank initialization
  ///
  /// \param mf mfcc object
  /// \param fmin start frequency, in Hz
  /// \param fmax end frequency, in Hz
  ///
  /// The filterbank will be initialized with bands linearly spaced in the mel
  /// scale, from `fmin` to `fmax`.
  ///
  /// See also
  /// --------
  ///
  /// aubio_filterbank_set_mel_coeffs()
  int aubio_mfcc_set_mel_coeffs(
    ffi.Pointer<aubio_mfcc_t> mf,
    double fmin,
    double fmax,
  ) {
    return _aubio_mfcc_set_mel_coeffs(mf, fmin, fmax);
  }

  late final _aubio_mfcc_set_mel_coeffsPtr =
      _lookup<
        ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_mfcc_t>, smpl_t, smpl_t)
        >
      >('aubio_mfcc_set_mel_coeffs');
  late final _aubio_mfcc_set_mel_coeffs = _aubio_mfcc_set_mel_coeffsPtr
      .asFunction<int Function(ffi.Pointer<aubio_mfcc_t>, double, double)>();

  /// Mel filterbank initialization
  ///
  /// \param mf mfcc object
  /// \param fmin start frequency, in Hz
  /// \param fmax end frequency, in Hz
  ///
  /// The bank of filters will be initalized to to cover linearly spaced bands in
  /// the Htk mel scale, from `fmin` to `fmax`.
  ///
  /// See also
  /// --------
  ///
  /// aubio_filterbank_set_mel_coeffs_htk()
  int aubio_mfcc_set_mel_coeffs_htk(
    ffi.Pointer<aubio_mfcc_t> mf,
    double fmin,
    double fmax,
  ) {
    return _aubio_mfcc_set_mel_coeffs_htk(mf, fmin, fmax);
  }

  late final _aubio_mfcc_set_mel_coeffs_htkPtr =
      _lookup<
        ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_mfcc_t>, smpl_t, smpl_t)
        >
      >('aubio_mfcc_set_mel_coeffs_htk');
  late final _aubio_mfcc_set_mel_coeffs_htk = _aubio_mfcc_set_mel_coeffs_htkPtr
      .asFunction<int Function(ffi.Pointer<aubio_mfcc_t>, double, double)>();

  /// Mel filterbank initialization (Auditory Toolbox's parameters)
  ///
  /// \param mf mfcc object
  ///
  /// The filter coefficients are built to match exactly Malcolm Slaney's Auditory
  /// Toolbox implementation. The number of filters should be 40.
  ///
  /// This is the default filterbank when `mf` was created with `n_filters = 40`.
  ///
  /// See also
  /// --------
  ///
  /// aubio_filterbank_set_mel_coeffs_slaney()
  int aubio_mfcc_set_mel_coeffs_slaney(ffi.Pointer<aubio_mfcc_t> mf) {
    return _aubio_mfcc_set_mel_coeffs_slaney(mf);
  }

  late final _aubio_mfcc_set_mel_coeffs_slaneyPtr =
      _lookup<ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_mfcc_t>)>>(
        'aubio_mfcc_set_mel_coeffs_slaney',
      );
  late final _aubio_mfcc_set_mel_coeffs_slaney =
      _aubio_mfcc_set_mel_coeffs_slaneyPtr
          .asFunction<int Function(ffi.Pointer<aubio_mfcc_t>)>();

  /// execute spectral description function on a spectral frame
  ///
  /// Generic function to compute spectral description.
  ///
  /// \param o spectral description object as returned by new_aubio_specdesc()
  /// \param fftgrain input signal spectrum as computed by aubio_pvoc_do
  /// \param desc output vector (one sample long, to send to the peak picking)
  void aubio_specdesc_do(
    ffi.Pointer<aubio_specdesc_t> o,
    ffi.Pointer<cvec_t> fftgrain,
    ffi.Pointer<fvec_t> desc,
  ) {
    return _aubio_specdesc_do(o, fftgrain, desc);
  }

  late final _aubio_specdesc_doPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<aubio_specdesc_t>,
            ffi.Pointer<cvec_t>,
            ffi.Pointer<fvec_t>,
          )
        >
      >('aubio_specdesc_do');
  late final _aubio_specdesc_do = _aubio_specdesc_doPtr
      .asFunction<
        void Function(
          ffi.Pointer<aubio_specdesc_t>,
          ffi.Pointer<cvec_t>,
          ffi.Pointer<fvec_t>,
        )
      >();

  /// creation of a spectral description object
  ///
  /// \param method spectral description method
  /// \param buf_size length of the input spectrum frame
  ///
  /// The parameter \p method is a string that can be any of:
  ///
  /// - onset novelty functions: `complex`, `energy`, `hfc`, `kl`, `mkl`,
  /// `phase`, `specdiff`, `specflux`, `wphase`,
  ///
  /// - spectral descriptors: `centroid`, `decrease`, `kurtosis`, `rolloff`,
  /// `skewness`, `slope`, `spread`.
  ffi.Pointer<aubio_specdesc_t> new_aubio_specdesc(
    ffi.Pointer<char_t> method,
    int buf_size,
  ) {
    return _new_aubio_specdesc(method, buf_size);
  }

  late final _new_aubio_specdescPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<aubio_specdesc_t> Function(ffi.Pointer<char_t>, uint_t)
        >
      >('new_aubio_specdesc');
  late final _new_aubio_specdesc = _new_aubio_specdescPtr
      .asFunction<
        ffi.Pointer<aubio_specdesc_t> Function(ffi.Pointer<char_t>, int)
      >();

  /// deletion of a spectral descriptor
  ///
  /// \param o spectral descriptor object as returned by new_aubio_specdesc()
  void del_aubio_specdesc(ffi.Pointer<aubio_specdesc_t> o) {
    return _del_aubio_specdesc(o);
  }

  late final _del_aubio_specdescPtr =
      _lookup<
        ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aubio_specdesc_t>)>
      >('del_aubio_specdesc');
  late final _del_aubio_specdesc = _del_aubio_specdescPtr
      .asFunction<void Function(ffi.Pointer<aubio_specdesc_t>)>();

  /// execute spectral adaptive whitening, in-place
  ///
  /// \param o spectral whitening object as returned by new_aubio_spectral_whitening()
  /// \param fftgrain input signal spectrum as computed by aubio_pvoc_do() or aubio_fft_do()
  void aubio_spectral_whitening_do(
    ffi.Pointer<aubio_spectral_whitening_t> o,
    ffi.Pointer<cvec_t> fftgrain,
  ) {
    return _aubio_spectral_whitening_do(o, fftgrain);
  }

  late final _aubio_spectral_whitening_doPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<aubio_spectral_whitening_t>,
            ffi.Pointer<cvec_t>,
          )
        >
      >('aubio_spectral_whitening_do');
  late final _aubio_spectral_whitening_do = _aubio_spectral_whitening_doPtr
      .asFunction<
        void Function(
          ffi.Pointer<aubio_spectral_whitening_t>,
          ffi.Pointer<cvec_t>,
        )
      >();

  /// creation of a spectral whitening object
  ///
  /// \param buf_size window size of input grains
  /// \param hop_size number of samples between two consecutive input grains
  /// \param samplerate sampling rate of the input signal
  ffi.Pointer<aubio_spectral_whitening_t> new_aubio_spectral_whitening(
    int buf_size,
    int hop_size,
    int samplerate,
  ) {
    return _new_aubio_spectral_whitening(buf_size, hop_size, samplerate);
  }

  late final _new_aubio_spectral_whiteningPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<aubio_spectral_whitening_t> Function(
            uint_t,
            uint_t,
            uint_t,
          )
        >
      >('new_aubio_spectral_whitening');
  late final _new_aubio_spectral_whitening = _new_aubio_spectral_whiteningPtr
      .asFunction<
        ffi.Pointer<aubio_spectral_whitening_t> Function(int, int, int)
      >();

  /// reset spectral whitening object
  ///
  /// \param o spectral whitening object as returned by new_aubio_spectral_whitening()
  void aubio_spectral_whitening_reset(
    ffi.Pointer<aubio_spectral_whitening_t> o,
  ) {
    return _aubio_spectral_whitening_reset(o);
  }

  late final _aubio_spectral_whitening_resetPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aubio_spectral_whitening_t>)
        >
      >('aubio_spectral_whitening_reset');
  late final _aubio_spectral_whitening_reset =
      _aubio_spectral_whitening_resetPtr
          .asFunction<void Function(ffi.Pointer<aubio_spectral_whitening_t>)>();

  /// set relaxation time for spectral whitening
  ///
  /// \param o spectral whitening object as returned by new_aubio_spectral_whitening()
  /// \param relax_time relaxation time in seconds between 20 and 500, defaults 250
  int aubio_spectral_whitening_set_relax_time(
    ffi.Pointer<aubio_spectral_whitening_t> o,
    double relax_time,
  ) {
    return _aubio_spectral_whitening_set_relax_time(o, relax_time);
  }

  late final _aubio_spectral_whitening_set_relax_timePtr =
      _lookup<
        ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_spectral_whitening_t>, smpl_t)
        >
      >('aubio_spectral_whitening_set_relax_time');
  late final _aubio_spectral_whitening_set_relax_time =
      _aubio_spectral_whitening_set_relax_timePtr
          .asFunction<
            int Function(ffi.Pointer<aubio_spectral_whitening_t>, double)
          >();

  /// get relaxation time of spectral whitening
  ///
  /// \param o spectral whitening object as returned by new_aubio_spectral_whitening()
  /// \return relaxation time in seconds
  double aubio_spectral_whitening_get_relax_time(
    ffi.Pointer<aubio_spectral_whitening_t> o,
  ) {
    return _aubio_spectral_whitening_get_relax_time(o);
  }

  late final _aubio_spectral_whitening_get_relax_timePtr =
      _lookup<
        ffi.NativeFunction<
          smpl_t Function(ffi.Pointer<aubio_spectral_whitening_t>)
        >
      >('aubio_spectral_whitening_get_relax_time');
  late final _aubio_spectral_whitening_get_relax_time =
      _aubio_spectral_whitening_get_relax_timePtr
          .asFunction<
            double Function(ffi.Pointer<aubio_spectral_whitening_t>)
          >();

  /// set floor for spectral whitening
  ///
  /// \param o spectral whitening object as returned by new_aubio_spectral_whitening()
  /// \param floor value (typically between 1.e-6 and .2, defaults to 1.e-4)
  int aubio_spectral_whitening_set_floor(
    ffi.Pointer<aubio_spectral_whitening_t> o,
    double floor,
  ) {
    return _aubio_spectral_whitening_set_floor(o, floor);
  }

  late final _aubio_spectral_whitening_set_floorPtr =
      _lookup<
        ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_spectral_whitening_t>, smpl_t)
        >
      >('aubio_spectral_whitening_set_floor');
  late final _aubio_spectral_whitening_set_floor =
      _aubio_spectral_whitening_set_floorPtr
          .asFunction<
            int Function(ffi.Pointer<aubio_spectral_whitening_t>, double)
          >();

  /// get floor of spectral whitening
  ///
  /// \param o spectral whitening object as returned by new_aubio_spectral_whitening()
  /// \return floor value
  double aubio_spectral_whitening_get_floor(
    ffi.Pointer<aubio_spectral_whitening_t> o,
  ) {
    return _aubio_spectral_whitening_get_floor(o);
  }

  late final _aubio_spectral_whitening_get_floorPtr =
      _lookup<
        ffi.NativeFunction<
          smpl_t Function(ffi.Pointer<aubio_spectral_whitening_t>)
        >
      >('aubio_spectral_whitening_get_floor');
  late final _aubio_spectral_whitening_get_floor =
      _aubio_spectral_whitening_get_floorPtr
          .asFunction<
            double Function(ffi.Pointer<aubio_spectral_whitening_t>)
          >();

  /// deletion of a spectral whitening
  ///
  /// \param o spectral whitening object as returned by new_aubio_spectral_whitening()
  void del_aubio_spectral_whitening(ffi.Pointer<aubio_spectral_whitening_t> o) {
    return _del_aubio_spectral_whitening(o);
  }

  late final _del_aubio_spectral_whiteningPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aubio_spectral_whitening_t>)
        >
      >('del_aubio_spectral_whitening');
  late final _del_aubio_spectral_whitening = _del_aubio_spectral_whiteningPtr
      .asFunction<void Function(ffi.Pointer<aubio_spectral_whitening_t>)>();

  /// create tss object
  ///
  /// \param buf_size buffer size
  /// \param hop_size step size
  ffi.Pointer<aubio_tss_t> new_aubio_tss(int buf_size, int hop_size) {
    return _new_aubio_tss(buf_size, hop_size);
  }

  late final _new_aubio_tssPtr =
      _lookup<
        ffi.NativeFunction<ffi.Pointer<aubio_tss_t> Function(uint_t, uint_t)>
      >('new_aubio_tss');
  late final _new_aubio_tss = _new_aubio_tssPtr
      .asFunction<ffi.Pointer<aubio_tss_t> Function(int, int)>();

  /// delete tss object
  ///
  /// \param o tss object as returned by new_aubio_tss()
  void del_aubio_tss(ffi.Pointer<aubio_tss_t> o) {
    return _del_aubio_tss(o);
  }

  late final _del_aubio_tssPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aubio_tss_t>)>>(
        'del_aubio_tss',
      );
  late final _del_aubio_tss = _del_aubio_tssPtr
      .asFunction<void Function(ffi.Pointer<aubio_tss_t>)>();

  /// split input into transient and steady states components
  ///
  /// \param o tss object as returned by new_aubio_tss()
  /// \param input input spectral frame
  /// \param trans output transient components
  /// \param stead output steady state components
  void aubio_tss_do(
    ffi.Pointer<aubio_tss_t> o,
    ffi.Pointer<cvec_t> input,
    ffi.Pointer<cvec_t> trans,
    ffi.Pointer<cvec_t> stead,
  ) {
    return _aubio_tss_do(o, input, trans, stead);
  }

  late final _aubio_tss_doPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<aubio_tss_t>,
            ffi.Pointer<cvec_t>,
            ffi.Pointer<cvec_t>,
            ffi.Pointer<cvec_t>,
          )
        >
      >('aubio_tss_do');
  late final _aubio_tss_do = _aubio_tss_doPtr
      .asFunction<
        void Function(
          ffi.Pointer<aubio_tss_t>,
          ffi.Pointer<cvec_t>,
          ffi.Pointer<cvec_t>,
          ffi.Pointer<cvec_t>,
        )
      >();

  /// set transient / steady state separation threshold
  ///
  /// \param o tss object as returned by new_aubio_tss()
  /// \param thrs new threshold value
  int aubio_tss_set_threshold(ffi.Pointer<aubio_tss_t> o, double thrs) {
    return _aubio_tss_set_threshold(o, thrs);
  }

  late final _aubio_tss_set_thresholdPtr =
      _lookup<
        ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_tss_t>, smpl_t)>
      >('aubio_tss_set_threshold');
  late final _aubio_tss_set_threshold = _aubio_tss_set_thresholdPtr
      .asFunction<int Function(ffi.Pointer<aubio_tss_t>, double)>();

  /// set parameter a, defaults to 3
  ///
  /// \param o tss object as returned by new_aubio_tss()
  /// \param alpha new value for alpha parameter
  int aubio_tss_set_alpha(ffi.Pointer<aubio_tss_t> o, double alpha) {
    return _aubio_tss_set_alpha(o, alpha);
  }

  late final _aubio_tss_set_alphaPtr =
      _lookup<
        ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_tss_t>, smpl_t)>
      >('aubio_tss_set_alpha');
  late final _aubio_tss_set_alpha = _aubio_tss_set_alphaPtr
      .asFunction<int Function(ffi.Pointer<aubio_tss_t>, double)>();

  /// set parameter b, defaults to 3
  ///
  /// \param o tss object as returned by new_aubio_tss()
  /// \param beta new value for beta parameter
  int aubio_tss_set_beta(ffi.Pointer<aubio_tss_t> o, double beta) {
    return _aubio_tss_set_beta(o, beta);
  }

  late final _aubio_tss_set_betaPtr =
      _lookup<
        ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_tss_t>, smpl_t)>
      >('aubio_tss_set_beta');
  late final _aubio_tss_set_beta = _aubio_tss_set_betaPtr
      .asFunction<int Function(ffi.Pointer<aubio_tss_t>, double)>();

  /// execute pitch detection on an input signal frame
  ///
  /// \param o pitch detection object as returned by new_aubio_pitch()
  /// \param in input signal of size [hop_size]
  /// \param out output pitch candidates of size [1]
  void aubio_pitch_do(
    ffi.Pointer<aubio_pitch_t> o,
    ffi.Pointer<fvec_t> in$,
    ffi.Pointer<fvec_t> out,
  ) {
    return _aubio_pitch_do(o, in$, out);
  }

  late final _aubio_pitch_doPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<aubio_pitch_t>,
            ffi.Pointer<fvec_t>,
            ffi.Pointer<fvec_t>,
          )
        >
      >('aubio_pitch_do');
  late final _aubio_pitch_do = _aubio_pitch_doPtr
      .asFunction<
        void Function(
          ffi.Pointer<aubio_pitch_t>,
          ffi.Pointer<fvec_t>,
          ffi.Pointer<fvec_t>,
        )
      >();

  /// change yin or yinfft tolerance threshold
  ///
  /// \param o pitch detection object as returned by new_aubio_pitch()
  /// \param tol tolerance default is 0.15 for yin and 0.85 for yinfft
  int aubio_pitch_set_tolerance(ffi.Pointer<aubio_pitch_t> o, double tol) {
    return _aubio_pitch_set_tolerance(o, tol);
  }

  late final _aubio_pitch_set_tolerancePtr =
      _lookup<
        ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_pitch_t>, smpl_t)>
      >('aubio_pitch_set_tolerance');
  late final _aubio_pitch_set_tolerance = _aubio_pitch_set_tolerancePtr
      .asFunction<int Function(ffi.Pointer<aubio_pitch_t>, double)>();

  /// get yin or yinfft tolerance threshold
  ///
  /// \param o pitch detection object as returned by new_aubio_pitch()
  /// \return tolerance (default is 0.15 for yin and 0.85 for yinfft)
  double aubio_pitch_get_tolerance(ffi.Pointer<aubio_pitch_t> o) {
    return _aubio_pitch_get_tolerance(o);
  }

  late final _aubio_pitch_get_tolerancePtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_pitch_t>)>>(
        'aubio_pitch_get_tolerance',
      );
  late final _aubio_pitch_get_tolerance = _aubio_pitch_get_tolerancePtr
      .asFunction<double Function(ffi.Pointer<aubio_pitch_t>)>();

  /// deletion of the pitch detection object
  ///
  /// \param o pitch detection object as returned by new_aubio_pitch()
  void del_aubio_pitch(ffi.Pointer<aubio_pitch_t> o) {
    return _del_aubio_pitch(o);
  }

  late final _del_aubio_pitchPtr =
      _lookup<
        ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aubio_pitch_t>)>
      >('del_aubio_pitch');
  late final _del_aubio_pitch = _del_aubio_pitchPtr
      .asFunction<void Function(ffi.Pointer<aubio_pitch_t>)>();

  /// creation of the pitch detection object
  ///
  /// \param method set pitch detection algorithm
  /// \param buf_size size of the input buffer to analyse
  /// \param hop_size step size between two consecutive analysis instant
  /// \param samplerate sampling rate of the signal
  ///
  /// \return newly created ::aubio_pitch_t
  ffi.Pointer<aubio_pitch_t> new_aubio_pitch(
    ffi.Pointer<char_t> method,
    int buf_size,
    int hop_size,
    int samplerate,
  ) {
    return _new_aubio_pitch(method, buf_size, hop_size, samplerate);
  }

  late final _new_aubio_pitchPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<aubio_pitch_t> Function(
            ffi.Pointer<char_t>,
            uint_t,
            uint_t,
            uint_t,
          )
        >
      >('new_aubio_pitch');
  late final _new_aubio_pitch = _new_aubio_pitchPtr
      .asFunction<
        ffi.Pointer<aubio_pitch_t> Function(ffi.Pointer<char_t>, int, int, int)
      >();

  /// set the output unit of the pitch detection object
  ///
  /// \param o pitch detection object as returned by new_aubio_pitch()
  /// \param mode set pitch units for output
  ///
  /// mode can be one of "Hz", "midi", "cent", or "bin". Defaults to "Hz".
  ///
  /// \return 0 if successfull, non-zero otherwise
  int aubio_pitch_set_unit(
    ffi.Pointer<aubio_pitch_t> o,
    ffi.Pointer<char_t> mode,
  ) {
    return _aubio_pitch_set_unit(o, mode);
  }

  late final _aubio_pitch_set_unitPtr =
      _lookup<
        ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_pitch_t>, ffi.Pointer<char_t>)
        >
      >('aubio_pitch_set_unit');
  late final _aubio_pitch_set_unit = _aubio_pitch_set_unitPtr
      .asFunction<
        int Function(ffi.Pointer<aubio_pitch_t>, ffi.Pointer<char_t>)
      >();

  /// set the silence threshold of the pitch detection object
  ///
  /// \param o pitch detection object as returned by new_aubio_pitch()
  /// \param silence level threshold under which pitch should be ignored, in dB
  ///
  /// \return 0 if successfull, non-zero otherwise
  int aubio_pitch_set_silence(ffi.Pointer<aubio_pitch_t> o, double silence) {
    return _aubio_pitch_set_silence(o, silence);
  }

  late final _aubio_pitch_set_silencePtr =
      _lookup<
        ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_pitch_t>, smpl_t)>
      >('aubio_pitch_set_silence');
  late final _aubio_pitch_set_silence = _aubio_pitch_set_silencePtr
      .asFunction<int Function(ffi.Pointer<aubio_pitch_t>, double)>();

  /// set the silence threshold of the pitch detection object
  ///
  /// \param o pitch detection object as returned by ::new_aubio_pitch()
  ///
  /// \return level threshold under which pitch should be ignored, in dB
  double aubio_pitch_get_silence(ffi.Pointer<aubio_pitch_t> o) {
    return _aubio_pitch_get_silence(o);
  }

  late final _aubio_pitch_get_silencePtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_pitch_t>)>>(
        'aubio_pitch_get_silence',
      );
  late final _aubio_pitch_get_silence = _aubio_pitch_get_silencePtr
      .asFunction<double Function(ffi.Pointer<aubio_pitch_t>)>();

  /// get the current confidence
  ///
  /// \param o pitch detection object as returned by new_aubio_pitch()
  ///
  /// \return the current confidence of the pitch algorithm
  double aubio_pitch_get_confidence(ffi.Pointer<aubio_pitch_t> o) {
    return _aubio_pitch_get_confidence(o);
  }

  late final _aubio_pitch_get_confidencePtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_pitch_t>)>>(
        'aubio_pitch_get_confidence',
      );
  late final _aubio_pitch_get_confidence = _aubio_pitch_get_confidencePtr
      .asFunction<double Function(ffi.Pointer<aubio_pitch_t>)>();

  /// create onset detection object
  ///
  /// \param method onset detection type as specified in specdesc.h
  /// \param buf_size buffer size for phase vocoder
  /// \param hop_size hop size for phase vocoder
  /// \param samplerate sampling rate of the input signal
  ///
  /// \return newly created ::aubio_onset_t
  ffi.Pointer<aubio_onset_t> new_aubio_onset(
    ffi.Pointer<char_t> method,
    int buf_size,
    int hop_size,
    int samplerate,
  ) {
    return _new_aubio_onset(method, buf_size, hop_size, samplerate);
  }

  late final _new_aubio_onsetPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<aubio_onset_t> Function(
            ffi.Pointer<char_t>,
            uint_t,
            uint_t,
            uint_t,
          )
        >
      >('new_aubio_onset');
  late final _new_aubio_onset = _new_aubio_onsetPtr
      .asFunction<
        ffi.Pointer<aubio_onset_t> Function(ffi.Pointer<char_t>, int, int, int)
      >();

  /// execute onset detection
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \param input new audio vector of length hop_size
  /// \param onset output vector of length 1, containing 0 if no onset was found,
  /// and a value equal or greater than 1 otherwise
  ///
  /// When no onset was detected, the first element of the output vector `onset`
  /// is set to 0.
  ///
  /// When an onset is found, the first element of the output vector `onset` is set
  /// to `offset = 1 + a` where `a` is a number in the range`[0, 1]`.
  ///
  /// The final onset detection time, in samples, can be obtained with
  /// aubio_onset_get_last(). It can also be derived from `offset` as
  /// follows:
  ///
  /// \code
  /// t = total_frames + offset * hop_size - delay
  /// \endcode
  ///
  /// where `total_frames` is the total number of frames processed so far, and
  /// `delay` is the current delay of the onset object, as returned by
  /// aubio_onset_get_delay().
  void aubio_onset_do(
    ffi.Pointer<aubio_onset_t> o,
    ffi.Pointer<fvec_t> input,
    ffi.Pointer<fvec_t> onset,
  ) {
    return _aubio_onset_do(o, input, onset);
  }

  late final _aubio_onset_doPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<aubio_onset_t>,
            ffi.Pointer<fvec_t>,
            ffi.Pointer<fvec_t>,
          )
        >
      >('aubio_onset_do');
  late final _aubio_onset_do = _aubio_onset_doPtr
      .asFunction<
        void Function(
          ffi.Pointer<aubio_onset_t>,
          ffi.Pointer<fvec_t>,
          ffi.Pointer<fvec_t>,
        )
      >();

  /// get the time of the latest onset detected, in samples
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  ///
  /// \return onset detection timestamps (in samples)
  int aubio_onset_get_last(ffi.Pointer<aubio_onset_t> o) {
    return _aubio_onset_get_last(o);
  }

  late final _aubio_onset_get_lastPtr =
      _lookup<ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_onset_t>)>>(
        'aubio_onset_get_last',
      );
  late final _aubio_onset_get_last = _aubio_onset_get_lastPtr
      .asFunction<int Function(ffi.Pointer<aubio_onset_t>)>();

  /// get the time of the latest onset detected, in seconds
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  ///
  /// \return onset detection timestamps (in seconds)
  double aubio_onset_get_last_s(ffi.Pointer<aubio_onset_t> o) {
    return _aubio_onset_get_last_s(o);
  }

  late final _aubio_onset_get_last_sPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_onset_t>)>>(
        'aubio_onset_get_last_s',
      );
  late final _aubio_onset_get_last_s = _aubio_onset_get_last_sPtr
      .asFunction<double Function(ffi.Pointer<aubio_onset_t>)>();

  /// get the time of the latest onset detected, in milliseconds
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  ///
  /// \return onset detection timestamps (in milliseconds)
  double aubio_onset_get_last_ms(ffi.Pointer<aubio_onset_t> o) {
    return _aubio_onset_get_last_ms(o);
  }

  late final _aubio_onset_get_last_msPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_onset_t>)>>(
        'aubio_onset_get_last_ms',
      );
  late final _aubio_onset_get_last_ms = _aubio_onset_get_last_msPtr
      .asFunction<double Function(ffi.Pointer<aubio_onset_t>)>();

  /// set onset detection adaptive whitening
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \param enable 1 to enable, 0 to disable
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_onset_set_awhitening(ffi.Pointer<aubio_onset_t> o, int enable) {
    return _aubio_onset_set_awhitening(o, enable);
  }

  late final _aubio_onset_set_awhiteningPtr =
      _lookup<
        ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_onset_t>, uint_t)>
      >('aubio_onset_set_awhitening');
  late final _aubio_onset_set_awhitening = _aubio_onset_set_awhiteningPtr
      .asFunction<int Function(ffi.Pointer<aubio_onset_t>, int)>();

  /// get onset detection adaptive whitening
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  ///
  /// \return 1 if enabled, 0 otherwise
  double aubio_onset_get_awhitening(ffi.Pointer<aubio_onset_t> o) {
    return _aubio_onset_get_awhitening(o);
  }

  late final _aubio_onset_get_awhiteningPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_onset_t>)>>(
        'aubio_onset_get_awhitening',
      );
  late final _aubio_onset_get_awhitening = _aubio_onset_get_awhiteningPtr
      .asFunction<double Function(ffi.Pointer<aubio_onset_t>)>();

  /// set or disable log compression
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \param lambda logarithmic compression factor, 0 to disable
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_onset_set_compression(ffi.Pointer<aubio_onset_t> o, double lambda) {
    return _aubio_onset_set_compression(o, lambda);
  }

  late final _aubio_onset_set_compressionPtr =
      _lookup<
        ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_onset_t>, smpl_t)>
      >('aubio_onset_set_compression');
  late final _aubio_onset_set_compression = _aubio_onset_set_compressionPtr
      .asFunction<int Function(ffi.Pointer<aubio_onset_t>, double)>();

  /// get onset detection log compression
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  ///
  /// \returns 0 if disabled, compression factor otherwise
  double aubio_onset_get_compression(ffi.Pointer<aubio_onset_t> o) {
    return _aubio_onset_get_compression(o);
  }

  late final _aubio_onset_get_compressionPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_onset_t>)>>(
        'aubio_onset_get_compression',
      );
  late final _aubio_onset_get_compression = _aubio_onset_get_compressionPtr
      .asFunction<double Function(ffi.Pointer<aubio_onset_t>)>();

  /// set onset detection silence threshold
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \param silence new silence detection threshold
  int aubio_onset_set_silence(ffi.Pointer<aubio_onset_t> o, double silence) {
    return _aubio_onset_set_silence(o, silence);
  }

  late final _aubio_onset_set_silencePtr =
      _lookup<
        ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_onset_t>, smpl_t)>
      >('aubio_onset_set_silence');
  late final _aubio_onset_set_silence = _aubio_onset_set_silencePtr
      .asFunction<int Function(ffi.Pointer<aubio_onset_t>, double)>();

  /// get onset detection silence threshold
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  ///
  /// \return current silence threshold
  double aubio_onset_get_silence(ffi.Pointer<aubio_onset_t> o) {
    return _aubio_onset_get_silence(o);
  }

  late final _aubio_onset_get_silencePtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_onset_t>)>>(
        'aubio_onset_get_silence',
      );
  late final _aubio_onset_get_silence = _aubio_onset_get_silencePtr
      .asFunction<double Function(ffi.Pointer<aubio_onset_t>)>();

  /// get onset detection function
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \return the current value of the descriptor
  double aubio_onset_get_descriptor(ffi.Pointer<aubio_onset_t> o) {
    return _aubio_onset_get_descriptor(o);
  }

  late final _aubio_onset_get_descriptorPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_onset_t>)>>(
        'aubio_onset_get_descriptor',
      );
  late final _aubio_onset_get_descriptor = _aubio_onset_get_descriptorPtr
      .asFunction<double Function(ffi.Pointer<aubio_onset_t>)>();

  /// get thresholded onset detection function
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \return the value of the thresholded descriptor
  double aubio_onset_get_thresholded_descriptor(ffi.Pointer<aubio_onset_t> o) {
    return _aubio_onset_get_thresholded_descriptor(o);
  }

  late final _aubio_onset_get_thresholded_descriptorPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_onset_t>)>>(
        'aubio_onset_get_thresholded_descriptor',
      );
  late final _aubio_onset_get_thresholded_descriptor =
      _aubio_onset_get_thresholded_descriptorPtr
          .asFunction<double Function(ffi.Pointer<aubio_onset_t>)>();

  /// set onset detection peak picking threshold
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \param threshold new peak-picking threshold
  int aubio_onset_set_threshold(
    ffi.Pointer<aubio_onset_t> o,
    double threshold,
  ) {
    return _aubio_onset_set_threshold(o, threshold);
  }

  late final _aubio_onset_set_thresholdPtr =
      _lookup<
        ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_onset_t>, smpl_t)>
      >('aubio_onset_set_threshold');
  late final _aubio_onset_set_threshold = _aubio_onset_set_thresholdPtr
      .asFunction<int Function(ffi.Pointer<aubio_onset_t>, double)>();

  /// set minimum inter onset interval in samples
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \param minioi minimum interval between two consecutive onsets (in
  /// samples)
  int aubio_onset_set_minioi(ffi.Pointer<aubio_onset_t> o, int minioi) {
    return _aubio_onset_set_minioi(o, minioi);
  }

  late final _aubio_onset_set_minioiPtr =
      _lookup<
        ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_onset_t>, uint_t)>
      >('aubio_onset_set_minioi');
  late final _aubio_onset_set_minioi = _aubio_onset_set_minioiPtr
      .asFunction<int Function(ffi.Pointer<aubio_onset_t>, int)>();

  /// set minimum inter onset interval in seconds
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \param minioi minimum interval between two consecutive onsets (in
  /// seconds)
  int aubio_onset_set_minioi_s(ffi.Pointer<aubio_onset_t> o, double minioi) {
    return _aubio_onset_set_minioi_s(o, minioi);
  }

  late final _aubio_onset_set_minioi_sPtr =
      _lookup<
        ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_onset_t>, smpl_t)>
      >('aubio_onset_set_minioi_s');
  late final _aubio_onset_set_minioi_s = _aubio_onset_set_minioi_sPtr
      .asFunction<int Function(ffi.Pointer<aubio_onset_t>, double)>();

  /// set minimum inter onset interval in milliseconds
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \param minioi minimum interval between two consecutive onsets (in
  /// milliseconds)
  int aubio_onset_set_minioi_ms(ffi.Pointer<aubio_onset_t> o, double minioi) {
    return _aubio_onset_set_minioi_ms(o, minioi);
  }

  late final _aubio_onset_set_minioi_msPtr =
      _lookup<
        ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_onset_t>, smpl_t)>
      >('aubio_onset_set_minioi_ms');
  late final _aubio_onset_set_minioi_ms = _aubio_onset_set_minioi_msPtr
      .asFunction<int Function(ffi.Pointer<aubio_onset_t>, double)>();

  /// set delay in samples
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \param delay constant system delay to take back from detection time
  /// (in samples)
  int aubio_onset_set_delay(ffi.Pointer<aubio_onset_t> o, int delay) {
    return _aubio_onset_set_delay(o, delay);
  }

  late final _aubio_onset_set_delayPtr =
      _lookup<
        ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_onset_t>, uint_t)>
      >('aubio_onset_set_delay');
  late final _aubio_onset_set_delay = _aubio_onset_set_delayPtr
      .asFunction<int Function(ffi.Pointer<aubio_onset_t>, int)>();

  /// set delay in seconds
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \param delay constant system delay to take back from detection time
  /// (in seconds)
  int aubio_onset_set_delay_s(ffi.Pointer<aubio_onset_t> o, double delay) {
    return _aubio_onset_set_delay_s(o, delay);
  }

  late final _aubio_onset_set_delay_sPtr =
      _lookup<
        ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_onset_t>, smpl_t)>
      >('aubio_onset_set_delay_s');
  late final _aubio_onset_set_delay_s = _aubio_onset_set_delay_sPtr
      .asFunction<int Function(ffi.Pointer<aubio_onset_t>, double)>();

  /// set delay in milliseconds
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \param delay constant system delay to take back from detection time
  /// (in milliseconds)
  int aubio_onset_set_delay_ms(ffi.Pointer<aubio_onset_t> o, double delay) {
    return _aubio_onset_set_delay_ms(o, delay);
  }

  late final _aubio_onset_set_delay_msPtr =
      _lookup<
        ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_onset_t>, smpl_t)>
      >('aubio_onset_set_delay_ms');
  late final _aubio_onset_set_delay_ms = _aubio_onset_set_delay_msPtr
      .asFunction<int Function(ffi.Pointer<aubio_onset_t>, double)>();

  /// get minimum inter onset interval in samples
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \return minimum interval between two consecutive onsets (in
  /// samples)
  int aubio_onset_get_minioi(ffi.Pointer<aubio_onset_t> o) {
    return _aubio_onset_get_minioi(o);
  }

  late final _aubio_onset_get_minioiPtr =
      _lookup<ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_onset_t>)>>(
        'aubio_onset_get_minioi',
      );
  late final _aubio_onset_get_minioi = _aubio_onset_get_minioiPtr
      .asFunction<int Function(ffi.Pointer<aubio_onset_t>)>();

  /// get minimum inter onset interval in seconds
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \return minimum interval between two consecutive onsets (in
  /// seconds)
  double aubio_onset_get_minioi_s(ffi.Pointer<aubio_onset_t> o) {
    return _aubio_onset_get_minioi_s(o);
  }

  late final _aubio_onset_get_minioi_sPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_onset_t>)>>(
        'aubio_onset_get_minioi_s',
      );
  late final _aubio_onset_get_minioi_s = _aubio_onset_get_minioi_sPtr
      .asFunction<double Function(ffi.Pointer<aubio_onset_t>)>();

  /// get minimum inter onset interval in milliseconds
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \return minimum interval between two consecutive onsets (in
  /// milliseconds)
  double aubio_onset_get_minioi_ms(ffi.Pointer<aubio_onset_t> o) {
    return _aubio_onset_get_minioi_ms(o);
  }

  late final _aubio_onset_get_minioi_msPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_onset_t>)>>(
        'aubio_onset_get_minioi_ms',
      );
  late final _aubio_onset_get_minioi_ms = _aubio_onset_get_minioi_msPtr
      .asFunction<double Function(ffi.Pointer<aubio_onset_t>)>();

  /// get delay in samples
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \return constant system delay to take back from detection time
  /// (in samples)
  int aubio_onset_get_delay(ffi.Pointer<aubio_onset_t> o) {
    return _aubio_onset_get_delay(o);
  }

  late final _aubio_onset_get_delayPtr =
      _lookup<ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_onset_t>)>>(
        'aubio_onset_get_delay',
      );
  late final _aubio_onset_get_delay = _aubio_onset_get_delayPtr
      .asFunction<int Function(ffi.Pointer<aubio_onset_t>)>();

  /// get delay in seconds
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \return constant system delay to take back from detection time
  /// (in seconds)
  double aubio_onset_get_delay_s(ffi.Pointer<aubio_onset_t> o) {
    return _aubio_onset_get_delay_s(o);
  }

  late final _aubio_onset_get_delay_sPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_onset_t>)>>(
        'aubio_onset_get_delay_s',
      );
  late final _aubio_onset_get_delay_s = _aubio_onset_get_delay_sPtr
      .asFunction<double Function(ffi.Pointer<aubio_onset_t>)>();

  /// get delay in milliseconds
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \return constant system delay to take back from detection time
  /// (in milliseconds)
  double aubio_onset_get_delay_ms(ffi.Pointer<aubio_onset_t> o) {
    return _aubio_onset_get_delay_ms(o);
  }

  late final _aubio_onset_get_delay_msPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_onset_t>)>>(
        'aubio_onset_get_delay_ms',
      );
  late final _aubio_onset_get_delay_ms = _aubio_onset_get_delay_msPtr
      .asFunction<double Function(ffi.Pointer<aubio_onset_t>)>();

  /// get onset peak picking threshold
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \return current onset detection threshold
  double aubio_onset_get_threshold(ffi.Pointer<aubio_onset_t> o) {
    return _aubio_onset_get_threshold(o);
  }

  late final _aubio_onset_get_thresholdPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_onset_t>)>>(
        'aubio_onset_get_threshold',
      );
  late final _aubio_onset_get_threshold = _aubio_onset_get_thresholdPtr
      .asFunction<double Function(ffi.Pointer<aubio_onset_t>)>();

  /// set default parameters
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \param onset_mode detection mode to adjust
  ///
  /// This function is called at the end of new_aubio_onset().
  int aubio_onset_set_default_parameters(
    ffi.Pointer<aubio_onset_t> o,
    ffi.Pointer<char_t> onset_mode,
  ) {
    return _aubio_onset_set_default_parameters(o, onset_mode);
  }

  late final _aubio_onset_set_default_parametersPtr =
      _lookup<
        ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_onset_t>, ffi.Pointer<char_t>)
        >
      >('aubio_onset_set_default_parameters');
  late final _aubio_onset_set_default_parameters =
      _aubio_onset_set_default_parametersPtr
          .asFunction<
            int Function(ffi.Pointer<aubio_onset_t>, ffi.Pointer<char_t>)
          >();

  /// reset onset detection
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  ///
  /// Reset current time and last onset to 0.
  ///
  /// This function is called at the end of new_aubio_onset().
  void aubio_onset_reset(ffi.Pointer<aubio_onset_t> o) {
    return _aubio_onset_reset(o);
  }

  late final _aubio_onset_resetPtr =
      _lookup<
        ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aubio_onset_t>)>
      >('aubio_onset_reset');
  late final _aubio_onset_reset = _aubio_onset_resetPtr
      .asFunction<void Function(ffi.Pointer<aubio_onset_t>)>();

  /// delete onset detection object
  ///
  /// \param o onset detection object to delete
  void del_aubio_onset(ffi.Pointer<aubio_onset_t> o) {
    return _del_aubio_onset(o);
  }

  late final _del_aubio_onsetPtr =
      _lookup<
        ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aubio_onset_t>)>
      >('del_aubio_onset');
  late final _del_aubio_onset = _del_aubio_onsetPtr
      .asFunction<void Function(ffi.Pointer<aubio_onset_t>)>();

  /// create tempo detection object
  ///
  /// \param method beat tracking method, unused for now (use "default")
  /// \param buf_size length of FFT
  /// \param hop_size number of frames between two consecutive runs
  /// \param samplerate sampling rate of the signal to analyze
  ///
  /// \return newly created ::aubio_tempo_t if successful, `NULL` otherwise
  ffi.Pointer<aubio_tempo_t> new_aubio_tempo(
    ffi.Pointer<char_t> method,
    int buf_size,
    int hop_size,
    int samplerate,
  ) {
    return _new_aubio_tempo(method, buf_size, hop_size, samplerate);
  }

  late final _new_aubio_tempoPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<aubio_tempo_t> Function(
            ffi.Pointer<char_t>,
            uint_t,
            uint_t,
            uint_t,
          )
        >
      >('new_aubio_tempo');
  late final _new_aubio_tempo = _new_aubio_tempoPtr
      .asFunction<
        ffi.Pointer<aubio_tempo_t> Function(ffi.Pointer<char_t>, int, int, int)
      >();

  /// execute tempo detection
  ///
  /// \param o beat tracking object
  /// \param input new samples
  /// \param tempo output beats
  void aubio_tempo_do(
    ffi.Pointer<aubio_tempo_t> o,
    ffi.Pointer<fvec_t> input,
    ffi.Pointer<fvec_t> tempo,
  ) {
    return _aubio_tempo_do(o, input, tempo);
  }

  late final _aubio_tempo_doPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<aubio_tempo_t>,
            ffi.Pointer<fvec_t>,
            ffi.Pointer<fvec_t>,
          )
        >
      >('aubio_tempo_do');
  late final _aubio_tempo_do = _aubio_tempo_doPtr
      .asFunction<
        void Function(
          ffi.Pointer<aubio_tempo_t>,
          ffi.Pointer<fvec_t>,
          ffi.Pointer<fvec_t>,
        )
      >();

  /// get the time of the latest beat detected, in samples
  ///
  /// \param o tempo detection object as returned by ::new_aubio_tempo
  int aubio_tempo_get_last(ffi.Pointer<aubio_tempo_t> o) {
    return _aubio_tempo_get_last(o);
  }

  late final _aubio_tempo_get_lastPtr =
      _lookup<ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_tempo_t>)>>(
        'aubio_tempo_get_last',
      );
  late final _aubio_tempo_get_last = _aubio_tempo_get_lastPtr
      .asFunction<int Function(ffi.Pointer<aubio_tempo_t>)>();

  /// get the time of the latest beat detected, in seconds
  ///
  /// \param o tempo detection object as returned by ::new_aubio_tempo
  double aubio_tempo_get_last_s(ffi.Pointer<aubio_tempo_t> o) {
    return _aubio_tempo_get_last_s(o);
  }

  late final _aubio_tempo_get_last_sPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_tempo_t>)>>(
        'aubio_tempo_get_last_s',
      );
  late final _aubio_tempo_get_last_s = _aubio_tempo_get_last_sPtr
      .asFunction<double Function(ffi.Pointer<aubio_tempo_t>)>();

  /// get the time of the latest beat detected, in milliseconds
  ///
  /// \param o tempo detection object as returned by ::new_aubio_tempo
  double aubio_tempo_get_last_ms(ffi.Pointer<aubio_tempo_t> o) {
    return _aubio_tempo_get_last_ms(o);
  }

  late final _aubio_tempo_get_last_msPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_tempo_t>)>>(
        'aubio_tempo_get_last_ms',
      );
  late final _aubio_tempo_get_last_ms = _aubio_tempo_get_last_msPtr
      .asFunction<double Function(ffi.Pointer<aubio_tempo_t>)>();

  /// set tempo detection silence threshold
  ///
  /// \param o beat tracking object
  /// \param silence new silence threshold, in dB
  ///
  /// \return `0` if successful, non-zero otherwise
  int aubio_tempo_set_silence(ffi.Pointer<aubio_tempo_t> o, double silence) {
    return _aubio_tempo_set_silence(o, silence);
  }

  late final _aubio_tempo_set_silencePtr =
      _lookup<
        ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_tempo_t>, smpl_t)>
      >('aubio_tempo_set_silence');
  late final _aubio_tempo_set_silence = _aubio_tempo_set_silencePtr
      .asFunction<int Function(ffi.Pointer<aubio_tempo_t>, double)>();

  /// get tempo detection silence threshold
  ///
  /// \param o tempo detection object as returned by new_aubio_tempo()
  ///
  /// \return current silence threshold
  double aubio_tempo_get_silence(ffi.Pointer<aubio_tempo_t> o) {
    return _aubio_tempo_get_silence(o);
  }

  late final _aubio_tempo_get_silencePtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_tempo_t>)>>(
        'aubio_tempo_get_silence',
      );
  late final _aubio_tempo_get_silence = _aubio_tempo_get_silencePtr
      .asFunction<double Function(ffi.Pointer<aubio_tempo_t>)>();

  /// set tempo detection peak picking threshold
  ///
  /// \param o beat tracking object
  /// \param threshold new threshold
  ///
  /// \return `0` if successful, non-zero otherwise
  int aubio_tempo_set_threshold(
    ffi.Pointer<aubio_tempo_t> o,
    double threshold,
  ) {
    return _aubio_tempo_set_threshold(o, threshold);
  }

  late final _aubio_tempo_set_thresholdPtr =
      _lookup<
        ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_tempo_t>, smpl_t)>
      >('aubio_tempo_set_threshold');
  late final _aubio_tempo_set_threshold = _aubio_tempo_set_thresholdPtr
      .asFunction<int Function(ffi.Pointer<aubio_tempo_t>, double)>();

  /// get tempo peak picking threshold
  ///
  /// \param o tempo detection object as returned by new_aubio_tempo()
  ///
  /// \return current tempo detection threshold
  double aubio_tempo_get_threshold(ffi.Pointer<aubio_tempo_t> o) {
    return _aubio_tempo_get_threshold(o);
  }

  late final _aubio_tempo_get_thresholdPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_tempo_t>)>>(
        'aubio_tempo_get_threshold',
      );
  late final _aubio_tempo_get_threshold = _aubio_tempo_get_thresholdPtr
      .asFunction<double Function(ffi.Pointer<aubio_tempo_t>)>();

  /// get current beat period in samples
  ///
  /// \param bt beat tracking object
  ///
  /// Returns the currently observed period, in samples, or 0 if no consistent
  /// value is found.
  double aubio_tempo_get_period(ffi.Pointer<aubio_tempo_t> bt) {
    return _aubio_tempo_get_period(bt);
  }

  late final _aubio_tempo_get_periodPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_tempo_t>)>>(
        'aubio_tempo_get_period',
      );
  late final _aubio_tempo_get_period = _aubio_tempo_get_periodPtr
      .asFunction<double Function(ffi.Pointer<aubio_tempo_t>)>();

  /// get current beat period in seconds
  ///
  /// \param bt beat tracking object
  ///
  /// Returns the currently observed period, in seconds, or 0 if no consistent
  /// value is found.
  double aubio_tempo_get_period_s(ffi.Pointer<aubio_tempo_t> bt) {
    return _aubio_tempo_get_period_s(bt);
  }

  late final _aubio_tempo_get_period_sPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_tempo_t>)>>(
        'aubio_tempo_get_period_s',
      );
  late final _aubio_tempo_get_period_s = _aubio_tempo_get_period_sPtr
      .asFunction<double Function(ffi.Pointer<aubio_tempo_t>)>();

  /// get current tempo
  ///
  /// \param o beat tracking object
  ///
  /// \return the currently observed tempo, or `0` if no consistent value is found
  double aubio_tempo_get_bpm(ffi.Pointer<aubio_tempo_t> o) {
    return _aubio_tempo_get_bpm(o);
  }

  late final _aubio_tempo_get_bpmPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_tempo_t>)>>(
        'aubio_tempo_get_bpm',
      );
  late final _aubio_tempo_get_bpm = _aubio_tempo_get_bpmPtr
      .asFunction<double Function(ffi.Pointer<aubio_tempo_t>)>();

  /// get current tempo confidence
  ///
  /// \param o beat tracking object
  ///
  /// \return confidence with which the tempo has been observed, the higher the
  /// more confidence, `0` if no consistent value is found.
  double aubio_tempo_get_confidence(ffi.Pointer<aubio_tempo_t> o) {
    return _aubio_tempo_get_confidence(o);
  }

  late final _aubio_tempo_get_confidencePtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_tempo_t>)>>(
        'aubio_tempo_get_confidence',
      );
  late final _aubio_tempo_get_confidence = _aubio_tempo_get_confidencePtr
      .asFunction<double Function(ffi.Pointer<aubio_tempo_t>)>();

  /// set number of tatum per beat
  ///
  /// \param o beat tracking object
  /// \param signature number of tatum per beat (between 1 and 64)
  int aubio_tempo_set_tatum_signature(
    ffi.Pointer<aubio_tempo_t> o,
    int signature,
  ) {
    return _aubio_tempo_set_tatum_signature(o, signature);
  }

  late final _aubio_tempo_set_tatum_signaturePtr =
      _lookup<
        ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_tempo_t>, uint_t)>
      >('aubio_tempo_set_tatum_signature');
  late final _aubio_tempo_set_tatum_signature =
      _aubio_tempo_set_tatum_signaturePtr
          .asFunction<int Function(ffi.Pointer<aubio_tempo_t>, int)>();

  /// check whether a tatum was detected in the current frame
  ///
  /// \param o beat tracking object
  ///
  /// \return 2 if a beat was detected, 1 if a tatum was detected, 0 otherwise
  int aubio_tempo_was_tatum(ffi.Pointer<aubio_tempo_t> o) {
    return _aubio_tempo_was_tatum(o);
  }

  late final _aubio_tempo_was_tatumPtr =
      _lookup<ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_tempo_t>)>>(
        'aubio_tempo_was_tatum',
      );
  late final _aubio_tempo_was_tatum = _aubio_tempo_was_tatumPtr
      .asFunction<int Function(ffi.Pointer<aubio_tempo_t>)>();

  /// get position of last_tatum, in samples
  ///
  /// \param o beat tracking object
  double aubio_tempo_get_last_tatum(ffi.Pointer<aubio_tempo_t> o) {
    return _aubio_tempo_get_last_tatum(o);
  }

  late final _aubio_tempo_get_last_tatumPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_tempo_t>)>>(
        'aubio_tempo_get_last_tatum',
      );
  late final _aubio_tempo_get_last_tatum = _aubio_tempo_get_last_tatumPtr
      .asFunction<double Function(ffi.Pointer<aubio_tempo_t>)>();

  /// get current delay
  ///
  /// \param o beat tracking object
  ///
  /// \return current delay, in samples
  int aubio_tempo_get_delay(ffi.Pointer<aubio_tempo_t> o) {
    return _aubio_tempo_get_delay(o);
  }

  late final _aubio_tempo_get_delayPtr =
      _lookup<ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_tempo_t>)>>(
        'aubio_tempo_get_delay',
      );
  late final _aubio_tempo_get_delay = _aubio_tempo_get_delayPtr
      .asFunction<int Function(ffi.Pointer<aubio_tempo_t>)>();

  /// get current delay in seconds
  ///
  /// \param o beat tracking object
  ///
  /// \return current delay, in seconds
  double aubio_tempo_get_delay_s(ffi.Pointer<aubio_tempo_t> o) {
    return _aubio_tempo_get_delay_s(o);
  }

  late final _aubio_tempo_get_delay_sPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_tempo_t>)>>(
        'aubio_tempo_get_delay_s',
      );
  late final _aubio_tempo_get_delay_s = _aubio_tempo_get_delay_sPtr
      .asFunction<double Function(ffi.Pointer<aubio_tempo_t>)>();

  /// get current delay in ms
  ///
  /// \param o beat tracking object
  ///
  /// \return current delay, in milliseconds
  double aubio_tempo_get_delay_ms(ffi.Pointer<aubio_tempo_t> o) {
    return _aubio_tempo_get_delay_ms(o);
  }

  late final _aubio_tempo_get_delay_msPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_tempo_t>)>>(
        'aubio_tempo_get_delay_ms',
      );
  late final _aubio_tempo_get_delay_ms = _aubio_tempo_get_delay_msPtr
      .asFunction<double Function(ffi.Pointer<aubio_tempo_t>)>();

  /// set current delay
  ///
  /// \param o beat tracking object
  /// \param delay delay to set tempo to, in samples
  ///
  /// \return `0` if successful, non-zero otherwise
  int aubio_tempo_set_delay(ffi.Pointer<aubio_tempo_t> o, int delay) {
    return _aubio_tempo_set_delay(o, delay);
  }

  late final _aubio_tempo_set_delayPtr =
      _lookup<
        ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_tempo_t>, sint_t)>
      >('aubio_tempo_set_delay');
  late final _aubio_tempo_set_delay = _aubio_tempo_set_delayPtr
      .asFunction<int Function(ffi.Pointer<aubio_tempo_t>, int)>();

  /// set current delay in seconds
  ///
  /// \param o beat tracking object
  /// \param delay delay to set tempo to, in seconds
  ///
  /// \return `0` if successful, non-zero otherwise
  int aubio_tempo_set_delay_s(ffi.Pointer<aubio_tempo_t> o, double delay) {
    return _aubio_tempo_set_delay_s(o, delay);
  }

  late final _aubio_tempo_set_delay_sPtr =
      _lookup<
        ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_tempo_t>, smpl_t)>
      >('aubio_tempo_set_delay_s');
  late final _aubio_tempo_set_delay_s = _aubio_tempo_set_delay_sPtr
      .asFunction<int Function(ffi.Pointer<aubio_tempo_t>, double)>();

  /// set current delay
  ///
  /// \param o beat tracking object
  /// \param delay delay to set tempo to, in samples
  ///
  /// \return `0` if successful, non-zero otherwise
  int aubio_tempo_set_delay_ms(ffi.Pointer<aubio_tempo_t> o, double delay) {
    return _aubio_tempo_set_delay_ms(o, delay);
  }

  late final _aubio_tempo_set_delay_msPtr =
      _lookup<
        ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_tempo_t>, smpl_t)>
      >('aubio_tempo_set_delay_ms');
  late final _aubio_tempo_set_delay_ms = _aubio_tempo_set_delay_msPtr
      .asFunction<int Function(ffi.Pointer<aubio_tempo_t>, double)>();

  /// delete tempo detection object
  ///
  /// \param o beat tracking object
  void del_aubio_tempo(ffi.Pointer<aubio_tempo_t> o) {
    return _del_aubio_tempo(o);
  }

  late final _del_aubio_tempoPtr =
      _lookup<
        ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aubio_tempo_t>)>
      >('del_aubio_tempo');
  late final _del_aubio_tempo = _del_aubio_tempoPtr
      .asFunction<void Function(ffi.Pointer<aubio_tempo_t>)>();

  /// create notes detection object
  ///
  /// \param method notes detection type as specified in specdesc.h
  /// \param buf_size buffer size for phase vocoder
  /// \param hop_size hop size for phase vocoder
  /// \param samplerate sampling rate of the input signal
  ///
  /// \return newly created ::aubio_notes_t
  ffi.Pointer<aubio_notes_t> new_aubio_notes(
    ffi.Pointer<char_t> method,
    int buf_size,
    int hop_size,
    int samplerate,
  ) {
    return _new_aubio_notes(method, buf_size, hop_size, samplerate);
  }

  late final _new_aubio_notesPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<aubio_notes_t> Function(
            ffi.Pointer<char_t>,
            uint_t,
            uint_t,
            uint_t,
          )
        >
      >('new_aubio_notes');
  late final _new_aubio_notes = _new_aubio_notesPtr
      .asFunction<
        ffi.Pointer<aubio_notes_t> Function(ffi.Pointer<char_t>, int, int, int)
      >();

  /// delete notes detection object
  ///
  /// \param o notes detection object to delete
  void del_aubio_notes(ffi.Pointer<aubio_notes_t> o) {
    return _del_aubio_notes(o);
  }

  late final _del_aubio_notesPtr =
      _lookup<
        ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aubio_notes_t>)>
      >('del_aubio_notes');
  late final _del_aubio_notes = _del_aubio_notesPtr
      .asFunction<void Function(ffi.Pointer<aubio_notes_t>)>();

  /// execute note detection on an input signal frame
  ///
  /// \param o note detection object as returned by new_aubio_notes()
  /// \param input input signal of size [hop_size]
  /// \param output output notes, fvec of length 3
  ///
  /// The notes output is a vector of length 3 containing:
  /// - 0. the midi note value, or 0 if no note was found
  /// - 1. the note velocity
  /// - 2. the midi note to turn off
  void aubio_notes_do(
    ffi.Pointer<aubio_notes_t> o,
    ffi.Pointer<fvec_t> input,
    ffi.Pointer<fvec_t> output,
  ) {
    return _aubio_notes_do(o, input, output);
  }

  late final _aubio_notes_doPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<aubio_notes_t>,
            ffi.Pointer<fvec_t>,
            ffi.Pointer<fvec_t>,
          )
        >
      >('aubio_notes_do');
  late final _aubio_notes_do = _aubio_notes_doPtr
      .asFunction<
        void Function(
          ffi.Pointer<aubio_notes_t>,
          ffi.Pointer<fvec_t>,
          ffi.Pointer<fvec_t>,
        )
      >();

  /// set notes detection silence threshold
  ///
  /// \param o notes detection object as returned by new_aubio_notes()
  /// \param silence new silence detection threshold
  ///
  /// \return 0 on success, non-zero otherwise
  int aubio_notes_set_silence(ffi.Pointer<aubio_notes_t> o, double silence) {
    return _aubio_notes_set_silence(o, silence);
  }

  late final _aubio_notes_set_silencePtr =
      _lookup<
        ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_notes_t>, smpl_t)>
      >('aubio_notes_set_silence');
  late final _aubio_notes_set_silence = _aubio_notes_set_silencePtr
      .asFunction<int Function(ffi.Pointer<aubio_notes_t>, double)>();

  /// get notes detection silence threshold
  ///
  /// \param o notes detection object as returned by new_aubio_notes()
  ///
  /// \return current silence threshold
  double aubio_notes_get_silence(ffi.Pointer<aubio_notes_t> o) {
    return _aubio_notes_get_silence(o);
  }

  late final _aubio_notes_get_silencePtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_notes_t>)>>(
        'aubio_notes_get_silence',
      );
  late final _aubio_notes_get_silence = _aubio_notes_get_silencePtr
      .asFunction<double Function(ffi.Pointer<aubio_notes_t>)>();

  /// get notes detection minimum inter-onset interval, in millisecond
  ///
  /// \param o notes detection object as returned by new_aubio_notes()
  ///
  /// \return current minimum inter onset interval
  double aubio_notes_get_minioi_ms(ffi.Pointer<aubio_notes_t> o) {
    return _aubio_notes_get_minioi_ms(o);
  }

  late final _aubio_notes_get_minioi_msPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_notes_t>)>>(
        'aubio_notes_get_minioi_ms',
      );
  late final _aubio_notes_get_minioi_ms = _aubio_notes_get_minioi_msPtr
      .asFunction<double Function(ffi.Pointer<aubio_notes_t>)>();

  /// set notes detection minimum inter-onset interval, in millisecond
  ///
  /// \param o notes detection object as returned by new_aubio_notes()
  /// \param minioi_ms new inter-onset interval
  ///
  /// \return 0 on success, non-zero otherwise
  int aubio_notes_set_minioi_ms(
    ffi.Pointer<aubio_notes_t> o,
    double minioi_ms,
  ) {
    return _aubio_notes_set_minioi_ms(o, minioi_ms);
  }

  late final _aubio_notes_set_minioi_msPtr =
      _lookup<
        ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_notes_t>, smpl_t)>
      >('aubio_notes_set_minioi_ms');
  late final _aubio_notes_set_minioi_ms = _aubio_notes_set_minioi_msPtr
      .asFunction<int Function(ffi.Pointer<aubio_notes_t>, double)>();

  /// get notes object release drop level, in dB
  ///
  /// \param o notes detection object as returned by new_aubio_notes()
  ///
  /// \return current release drop level, in dB
  double aubio_notes_get_release_drop(ffi.Pointer<aubio_notes_t> o) {
    return _aubio_notes_get_release_drop(o);
  }

  late final _aubio_notes_get_release_dropPtr =
      _lookup<ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_notes_t>)>>(
        'aubio_notes_get_release_drop',
      );
  late final _aubio_notes_get_release_drop = _aubio_notes_get_release_dropPtr
      .asFunction<double Function(ffi.Pointer<aubio_notes_t>)>();

  /// set note release drop level, in dB
  ///
  /// This function sets the release_drop_level parameter, in dB. When a new note
  /// is found, the current level in dB is measured. If the measured level drops
  /// under that initial level - release_drop_level, then a note-off will be
  /// emitted.
  ///
  /// Defaults to `10`, in dB.
  ///
  /// \note This parameter was added in version `0.4.8`. Results obtained with
  /// earlier versions can be reproduced by setting this value to `100`, so that
  /// note-off will not be played until the next note.
  ///
  /// \param o notes detection object as returned by new_aubio_notes()
  /// \param release_drop new release drop level, in dB
  ///
  /// \return 0 on success, non-zero otherwise
  int aubio_notes_set_release_drop(
    ffi.Pointer<aubio_notes_t> o,
    double release_drop,
  ) {
    return _aubio_notes_set_release_drop(o, release_drop);
  }

  late final _aubio_notes_set_release_dropPtr =
      _lookup<
        ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_notes_t>, smpl_t)>
      >('aubio_notes_set_release_drop');
  late final _aubio_notes_set_release_drop = _aubio_notes_set_release_dropPtr
      .asFunction<int Function(ffi.Pointer<aubio_notes_t>, double)>();

  /// create new ::aubio_source_t
  ///
  /// \param uri the file path or uri to read from
  /// \param samplerate sampling rate to view the fie at
  /// \param hop_size the size of the blocks to read from
  ///
  /// Creates a new source object. If `0` is passed as `samplerate`, the sample
  /// rate of the original file is used.
  ///
  /// The samplerate of newly created source can be obtained using
  /// ::aubio_source_get_samplerate.
  ffi.Pointer<aubio_source_t> new_aubio_source(
    ffi.Pointer<char_t> uri,
    int samplerate,
    int hop_size,
  ) {
    return _new_aubio_source(uri, samplerate, hop_size);
  }

  late final _new_aubio_sourcePtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<aubio_source_t> Function(
            ffi.Pointer<char_t>,
            uint_t,
            uint_t,
          )
        >
      >('new_aubio_source');
  late final _new_aubio_source = _new_aubio_sourcePtr
      .asFunction<
        ffi.Pointer<aubio_source_t> Function(ffi.Pointer<char_t>, int, int)
      >();

  /// read monophonic vector of length hop_size from source object
  ///
  /// \param s source object, created with ::new_aubio_source
  /// \param read_to ::fvec_t of data to read to
  /// \param read upon returns, equals to number of frames actually read
  ///
  /// Upon returns, `read` contains the number of frames actually read from the
  /// source. `hop_size` if enough frames could be read, less otherwise.
  void aubio_source_do(
    ffi.Pointer<aubio_source_t> s,
    ffi.Pointer<fvec_t> read_to,
    ffi.Pointer<uint_t> read,
  ) {
    return _aubio_source_do(s, read_to, read);
  }

  late final _aubio_source_doPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<aubio_source_t>,
            ffi.Pointer<fvec_t>,
            ffi.Pointer<uint_t>,
          )
        >
      >('aubio_source_do');
  late final _aubio_source_do = _aubio_source_doPtr
      .asFunction<
        void Function(
          ffi.Pointer<aubio_source_t>,
          ffi.Pointer<fvec_t>,
          ffi.Pointer<uint_t>,
        )
      >();

  /// read polyphonic vector of length hop_size from source object
  ///
  /// \param s source object, created with ::new_aubio_source
  /// \param read_to ::fmat_t of data to read to
  /// \param[out] read upon returns, equals to number of frames actually read
  ///
  /// Upon returns, `read` contains the number of frames actually read from the
  /// source. `hop_size` if enough frames could be read, less otherwise.
  void aubio_source_do_multi(
    ffi.Pointer<aubio_source_t> s,
    ffi.Pointer<fmat_t> read_to,
    ffi.Pointer<uint_t> read,
  ) {
    return _aubio_source_do_multi(s, read_to, read);
  }

  late final _aubio_source_do_multiPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<aubio_source_t>,
            ffi.Pointer<fmat_t>,
            ffi.Pointer<uint_t>,
          )
        >
      >('aubio_source_do_multi');
  late final _aubio_source_do_multi = _aubio_source_do_multiPtr
      .asFunction<
        void Function(
          ffi.Pointer<aubio_source_t>,
          ffi.Pointer<fmat_t>,
          ffi.Pointer<uint_t>,
        )
      >();

  /// get samplerate of source object
  ///
  /// \param s source object, created with ::new_aubio_source
  /// \return samplerate, in Hz
  int aubio_source_get_samplerate(ffi.Pointer<aubio_source_t> s) {
    return _aubio_source_get_samplerate(s);
  }

  late final _aubio_source_get_sampleratePtr =
      _lookup<ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_source_t>)>>(
        'aubio_source_get_samplerate',
      );
  late final _aubio_source_get_samplerate = _aubio_source_get_sampleratePtr
      .asFunction<int Function(ffi.Pointer<aubio_source_t>)>();

  /// get channels of source object
  ///
  /// \param s source object, created with ::new_aubio_source
  /// \return channels
  int aubio_source_get_channels(ffi.Pointer<aubio_source_t> s) {
    return _aubio_source_get_channels(s);
  }

  late final _aubio_source_get_channelsPtr =
      _lookup<ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_source_t>)>>(
        'aubio_source_get_channels',
      );
  late final _aubio_source_get_channels = _aubio_source_get_channelsPtr
      .asFunction<int Function(ffi.Pointer<aubio_source_t>)>();

  /// seek source object
  ///
  /// \param s source object, created with ::new_aubio_source
  /// \param pos position to seek to, in frames
  ///
  /// \return 0 if sucessful, non-zero on failure
  int aubio_source_seek(ffi.Pointer<aubio_source_t> s, int pos) {
    return _aubio_source_seek(s, pos);
  }

  late final _aubio_source_seekPtr =
      _lookup<
        ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_source_t>, uint_t)>
      >('aubio_source_seek');
  late final _aubio_source_seek = _aubio_source_seekPtr
      .asFunction<int Function(ffi.Pointer<aubio_source_t>, int)>();

  /// get the duration of source object, in frames
  ///
  /// \param s source object, created with ::new_aubio_source
  /// \return number of frames in file
  int aubio_source_get_duration(ffi.Pointer<aubio_source_t> s) {
    return _aubio_source_get_duration(s);
  }

  late final _aubio_source_get_durationPtr =
      _lookup<ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_source_t>)>>(
        'aubio_source_get_duration',
      );
  late final _aubio_source_get_duration = _aubio_source_get_durationPtr
      .asFunction<int Function(ffi.Pointer<aubio_source_t>)>();

  /// close source object
  ///
  /// \param s source object, created with ::new_aubio_source
  ///
  /// \return 0 if sucessful, non-zero on failure
  int aubio_source_close(ffi.Pointer<aubio_source_t> s) {
    return _aubio_source_close(s);
  }

  late final _aubio_source_closePtr =
      _lookup<ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_source_t>)>>(
        'aubio_source_close',
      );
  late final _aubio_source_close = _aubio_source_closePtr
      .asFunction<int Function(ffi.Pointer<aubio_source_t>)>();

  /// close source and cleanup memory
  ///
  /// \param s source object, created with ::new_aubio_source
  void del_aubio_source(ffi.Pointer<aubio_source_t> s) {
    return _del_aubio_source(s);
  }

  late final _del_aubio_sourcePtr =
      _lookup<
        ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aubio_source_t>)>
      >('del_aubio_source');
  late final _del_aubio_source = _del_aubio_sourcePtr
      .asFunction<void Function(ffi.Pointer<aubio_source_t>)>();

  /// create new ::aubio_sink_t
  ///
  /// \param uri the file path or uri to write to
  /// \param samplerate sample rate to write the file at
  ///
  /// \return newly created ::aubio_sink_t
  ///
  /// Creates a new sink object.
  ///
  /// If samplerate is set to 0, the creation of the file will be delayed until
  /// both ::aubio_sink_preset_samplerate and ::aubio_sink_preset_channels have
  /// been called.
  ffi.Pointer<aubio_sink_t> new_aubio_sink(
    ffi.Pointer<char_t> uri,
    int samplerate,
  ) {
    return _new_aubio_sink(uri, samplerate);
  }

  late final _new_aubio_sinkPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<aubio_sink_t> Function(ffi.Pointer<char_t>, uint_t)
        >
      >('new_aubio_sink');
  late final _new_aubio_sink = _new_aubio_sinkPtr
      .asFunction<
        ffi.Pointer<aubio_sink_t> Function(ffi.Pointer<char_t>, int)
      >();

  /// preset sink samplerate
  ///
  /// \param s sink, created with ::new_aubio_sink
  /// \param samplerate samplerate to preset the sink to, in Hz
  ///
  /// \return 0 on success, 1 on error
  ///
  /// Preset the samplerate of the sink. The file should have been created using a
  /// samplerate of 0.
  ///
  /// The file will be opened only when both samplerate and channels have been set.
  int aubio_sink_preset_samplerate(
    ffi.Pointer<aubio_sink_t> s,
    int samplerate,
  ) {
    return _aubio_sink_preset_samplerate(s, samplerate);
  }

  late final _aubio_sink_preset_sampleratePtr =
      _lookup<
        ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_sink_t>, uint_t)>
      >('aubio_sink_preset_samplerate');
  late final _aubio_sink_preset_samplerate = _aubio_sink_preset_sampleratePtr
      .asFunction<int Function(ffi.Pointer<aubio_sink_t>, int)>();

  /// preset sink channels
  ///
  /// \param s sink, created with ::new_aubio_sink
  /// \param channels number of channels to preset the sink to
  ///
  /// \return 0 on success, 1 on error
  ///
  /// Preset the samplerate of the sink. The file should have been created using a
  /// samplerate of 0.
  ///
  /// The file will be opened only when both samplerate and channels have been set.
  int aubio_sink_preset_channels(ffi.Pointer<aubio_sink_t> s, int channels) {
    return _aubio_sink_preset_channels(s, channels);
  }

  late final _aubio_sink_preset_channelsPtr =
      _lookup<
        ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_sink_t>, uint_t)>
      >('aubio_sink_preset_channels');
  late final _aubio_sink_preset_channels = _aubio_sink_preset_channelsPtr
      .asFunction<int Function(ffi.Pointer<aubio_sink_t>, int)>();

  /// get samplerate of sink object
  ///
  /// \param s sink object, created with ::new_aubio_sink
  /// \return samplerate, in Hz
  int aubio_sink_get_samplerate(ffi.Pointer<aubio_sink_t> s) {
    return _aubio_sink_get_samplerate(s);
  }

  late final _aubio_sink_get_sampleratePtr =
      _lookup<ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_sink_t>)>>(
        'aubio_sink_get_samplerate',
      );
  late final _aubio_sink_get_samplerate = _aubio_sink_get_sampleratePtr
      .asFunction<int Function(ffi.Pointer<aubio_sink_t>)>();

  /// get channels of sink object
  ///
  /// \param s sink object, created with ::new_aubio_sink
  /// \return number of channels
  int aubio_sink_get_channels(ffi.Pointer<aubio_sink_t> s) {
    return _aubio_sink_get_channels(s);
  }

  late final _aubio_sink_get_channelsPtr =
      _lookup<ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_sink_t>)>>(
        'aubio_sink_get_channels',
      );
  late final _aubio_sink_get_channels = _aubio_sink_get_channelsPtr
      .asFunction<int Function(ffi.Pointer<aubio_sink_t>)>();

  /// write monophonic vector of length hop_size to sink
  ///
  /// \param s sink, created with ::new_aubio_sink
  /// \param write_data ::fvec_t samples to write to sink
  /// \param write number of frames to write
  void aubio_sink_do(
    ffi.Pointer<aubio_sink_t> s,
    ffi.Pointer<fvec_t> write_data,
    int write,
  ) {
    return _aubio_sink_do(s, write_data, write);
  }

  late final _aubio_sink_doPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<aubio_sink_t>,
            ffi.Pointer<fvec_t>,
            uint_t,
          )
        >
      >('aubio_sink_do');
  late final _aubio_sink_do = _aubio_sink_doPtr
      .asFunction<
        void Function(ffi.Pointer<aubio_sink_t>, ffi.Pointer<fvec_t>, int)
      >();

  /// write polyphonic vector of length hop_size to sink
  ///
  /// \param s sink, created with ::new_aubio_sink
  /// \param write_data ::fmat_t samples to write to sink
  /// \param write number of frames to write
  void aubio_sink_do_multi(
    ffi.Pointer<aubio_sink_t> s,
    ffi.Pointer<fmat_t> write_data,
    int write,
  ) {
    return _aubio_sink_do_multi(s, write_data, write);
  }

  late final _aubio_sink_do_multiPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<aubio_sink_t>,
            ffi.Pointer<fmat_t>,
            uint_t,
          )
        >
      >('aubio_sink_do_multi');
  late final _aubio_sink_do_multi = _aubio_sink_do_multiPtr
      .asFunction<
        void Function(ffi.Pointer<aubio_sink_t>, ffi.Pointer<fmat_t>, int)
      >();

  /// close sink
  ///
  /// \param s sink object, created with ::new_aubio_sink
  ///
  /// \return 0 on success, non-zero on failure
  int aubio_sink_close(ffi.Pointer<aubio_sink_t> s) {
    return _aubio_sink_close(s);
  }

  late final _aubio_sink_closePtr =
      _lookup<ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_sink_t>)>>(
        'aubio_sink_close',
      );
  late final _aubio_sink_close = _aubio_sink_closePtr
      .asFunction<int Function(ffi.Pointer<aubio_sink_t>)>();

  /// close sink and cleanup memory
  ///
  /// \param s sink object, created with ::new_aubio_sink
  void del_aubio_sink(ffi.Pointer<aubio_sink_t> s) {
    return _del_aubio_sink(s);
  }

  late final _del_aubio_sinkPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aubio_sink_t>)>>(
        'del_aubio_sink',
      );
  late final _del_aubio_sink = _del_aubio_sinkPtr
      .asFunction<void Function(ffi.Pointer<aubio_sink_t>)>();

  /// create new sampler object
  ///
  /// \param samplerate the sampling rate of the new sampler
  /// \param hop_size the block size of the new sampler
  ///
  /// \return the newly created ::aubio_sampler_t
  ffi.Pointer<aubio_sampler_t> new_aubio_sampler(int samplerate, int hop_size) {
    return _new_aubio_sampler(samplerate, hop_size);
  }

  late final _new_aubio_samplerPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<aubio_sampler_t> Function(uint_t, uint_t)
        >
      >('new_aubio_sampler');
  late final _new_aubio_sampler = _new_aubio_samplerPtr
      .asFunction<ffi.Pointer<aubio_sampler_t> Function(int, int)>();

  /// load source in sampler
  ///
  /// \param o sampler, created by new_aubio_sampler()
  /// \param uri the uri of the source to load
  ///
  /// \return 0 if successful, non-zero otherwise
  int aubio_sampler_load(
    ffi.Pointer<aubio_sampler_t> o,
    ffi.Pointer<char_t> uri,
  ) {
    return _aubio_sampler_load(o, uri);
  }

  late final _aubio_sampler_loadPtr =
      _lookup<
        ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_sampler_t>, ffi.Pointer<char_t>)
        >
      >('aubio_sampler_load');
  late final _aubio_sampler_load = _aubio_sampler_loadPtr
      .asFunction<
        int Function(ffi.Pointer<aubio_sampler_t>, ffi.Pointer<char_t>)
      >();

  /// process sampler function
  ///
  /// \param o sampler, created by new_aubio_sampler()
  /// \param input input of the sampler, to be added to the output
  /// \param output output of the sampler
  ///
  /// This function adds the new samples from the playing source to the output.
  ///
  /// If `input` is not NULL and different from `output`, then the samples from `input`
  /// are added to the output.
  void aubio_sampler_do(
    ffi.Pointer<aubio_sampler_t> o,
    ffi.Pointer<fvec_t> input,
    ffi.Pointer<fvec_t> output,
  ) {
    return _aubio_sampler_do(o, input, output);
  }

  late final _aubio_sampler_doPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<aubio_sampler_t>,
            ffi.Pointer<fvec_t>,
            ffi.Pointer<fvec_t>,
          )
        >
      >('aubio_sampler_do');
  late final _aubio_sampler_do = _aubio_sampler_doPtr
      .asFunction<
        void Function(
          ffi.Pointer<aubio_sampler_t>,
          ffi.Pointer<fvec_t>,
          ffi.Pointer<fvec_t>,
        )
      >();

  /// process sampler function, multiple channels
  ///
  /// \param o sampler, created by new_aubio_sampler()
  /// \param input input of the sampler, to be added to the output
  /// \param output output of the sampler
  ///
  /// This function adds the new samples from the playing source to the output.
  ///
  /// If `input` is not NULL and different from `output`, then the samples from `input`
  /// are added to the output.
  void aubio_sampler_do_multi(
    ffi.Pointer<aubio_sampler_t> o,
    ffi.Pointer<fmat_t> input,
    ffi.Pointer<fmat_t> output,
  ) {
    return _aubio_sampler_do_multi(o, input, output);
  }

  late final _aubio_sampler_do_multiPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<aubio_sampler_t>,
            ffi.Pointer<fmat_t>,
            ffi.Pointer<fmat_t>,
          )
        >
      >('aubio_sampler_do_multi');
  late final _aubio_sampler_do_multi = _aubio_sampler_do_multiPtr
      .asFunction<
        void Function(
          ffi.Pointer<aubio_sampler_t>,
          ffi.Pointer<fmat_t>,
          ffi.Pointer<fmat_t>,
        )
      >();

  /// get current playing state
  ///
  /// \param o sampler, created by new_aubio_sampler()
  ///
  /// \return 0 if not playing, 1 if playing
  int aubio_sampler_get_playing(ffi.Pointer<aubio_sampler_t> o) {
    return _aubio_sampler_get_playing(o);
  }

  late final _aubio_sampler_get_playingPtr =
      _lookup<
        ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_sampler_t>)>
      >('aubio_sampler_get_playing');
  late final _aubio_sampler_get_playing = _aubio_sampler_get_playingPtr
      .asFunction<int Function(ffi.Pointer<aubio_sampler_t>)>();

  /// set current playing state
  ///
  /// \param o sampler, created by new_aubio_sampler()
  /// \param playing 0 for not playing, 1 for playing
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_sampler_set_playing(ffi.Pointer<aubio_sampler_t> o, int playing) {
    return _aubio_sampler_set_playing(o, playing);
  }

  late final _aubio_sampler_set_playingPtr =
      _lookup<
        ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_sampler_t>, uint_t)
        >
      >('aubio_sampler_set_playing');
  late final _aubio_sampler_set_playing = _aubio_sampler_set_playingPtr
      .asFunction<int Function(ffi.Pointer<aubio_sampler_t>, int)>();

  /// play sample from start
  ///
  /// \param o sampler, created by new_aubio_sampler()
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_sampler_play(ffi.Pointer<aubio_sampler_t> o) {
    return _aubio_sampler_play(o);
  }

  late final _aubio_sampler_playPtr =
      _lookup<
        ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_sampler_t>)>
      >('aubio_sampler_play');
  late final _aubio_sampler_play = _aubio_sampler_playPtr
      .asFunction<int Function(ffi.Pointer<aubio_sampler_t>)>();

  /// stop sample
  ///
  /// \param o sampler, created by new_aubio_sampler()
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_sampler_stop(ffi.Pointer<aubio_sampler_t> o) {
    return _aubio_sampler_stop(o);
  }

  late final _aubio_sampler_stopPtr =
      _lookup<
        ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_sampler_t>)>
      >('aubio_sampler_stop');
  late final _aubio_sampler_stop = _aubio_sampler_stopPtr
      .asFunction<int Function(ffi.Pointer<aubio_sampler_t>)>();

  /// destroy ::aubio_sampler_t object
  ///
  /// \param o sampler, created by new_aubio_sampler()
  void del_aubio_sampler(ffi.Pointer<aubio_sampler_t> o) {
    return _del_aubio_sampler(o);
  }

  late final _del_aubio_samplerPtr =
      _lookup<
        ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aubio_sampler_t>)>
      >('del_aubio_sampler');
  late final _del_aubio_sampler = _del_aubio_samplerPtr
      .asFunction<void Function(ffi.Pointer<aubio_sampler_t>)>();

  /// create new wavetable object
  ///
  /// \param samplerate the sampling rate of the new wavetable
  /// \param hop_size the block size of the new wavetable
  ///
  /// \return the newly created aubio_wavetable_t
  ffi.Pointer<aubio_wavetable_t> new_aubio_wavetable(
    int samplerate,
    int hop_size,
  ) {
    return _new_aubio_wavetable(samplerate, hop_size);
  }

  late final _new_aubio_wavetablePtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<aubio_wavetable_t> Function(uint_t, uint_t)
        >
      >('new_aubio_wavetable');
  late final _new_aubio_wavetable = _new_aubio_wavetablePtr
      .asFunction<ffi.Pointer<aubio_wavetable_t> Function(int, int)>();

  /// load source in wavetable
  ///
  /// TODO: This function is not implemented yet. See new_aubio_sampler() instead.
  ///
  /// \param o wavetable, created by new_aubio_wavetable()
  /// \param uri the uri of the source to load
  ///
  /// \return 0 if successful, non-zero otherwise
  int aubio_wavetable_load(
    ffi.Pointer<aubio_wavetable_t> o,
    ffi.Pointer<char_t> uri,
  ) {
    return _aubio_wavetable_load(o, uri);
  }

  late final _aubio_wavetable_loadPtr =
      _lookup<
        ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_wavetable_t>, ffi.Pointer<char_t>)
        >
      >('aubio_wavetable_load');
  late final _aubio_wavetable_load = _aubio_wavetable_loadPtr
      .asFunction<
        int Function(ffi.Pointer<aubio_wavetable_t>, ffi.Pointer<char_t>)
      >();

  /// process wavetable function
  ///
  /// \param o wavetable, created by new_aubio_wavetable()
  /// \param input input of the wavetable, to be added to the output
  /// \param output output of the wavetable
  ///
  /// This function adds the new samples from the playing wavetable to the output.
  ///
  /// If `input` is not NULL and different from `output`, then the samples from `input`
  /// are added to the output.
  void aubio_wavetable_do(
    ffi.Pointer<aubio_wavetable_t> o,
    ffi.Pointer<fvec_t> input,
    ffi.Pointer<fvec_t> output,
  ) {
    return _aubio_wavetable_do(o, input, output);
  }

  late final _aubio_wavetable_doPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<aubio_wavetable_t>,
            ffi.Pointer<fvec_t>,
            ffi.Pointer<fvec_t>,
          )
        >
      >('aubio_wavetable_do');
  late final _aubio_wavetable_do = _aubio_wavetable_doPtr
      .asFunction<
        void Function(
          ffi.Pointer<aubio_wavetable_t>,
          ffi.Pointer<fvec_t>,
          ffi.Pointer<fvec_t>,
        )
      >();

  /// process wavetable function, multiple channels
  ///
  /// \param o wavetable, created by new_aubio_wavetable()
  /// \param input input of the wavetable, to be added to the output
  /// \param output output of the wavetable
  ///
  /// This function adds the new samples from the playing wavetable to the output.
  ///
  /// If `input` is not NULL and different from `output`, then the samples from `input`
  /// are added to the output.
  void aubio_wavetable_do_multi(
    ffi.Pointer<aubio_wavetable_t> o,
    ffi.Pointer<fmat_t> input,
    ffi.Pointer<fmat_t> output,
  ) {
    return _aubio_wavetable_do_multi(o, input, output);
  }

  late final _aubio_wavetable_do_multiPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<aubio_wavetable_t>,
            ffi.Pointer<fmat_t>,
            ffi.Pointer<fmat_t>,
          )
        >
      >('aubio_wavetable_do_multi');
  late final _aubio_wavetable_do_multi = _aubio_wavetable_do_multiPtr
      .asFunction<
        void Function(
          ffi.Pointer<aubio_wavetable_t>,
          ffi.Pointer<fmat_t>,
          ffi.Pointer<fmat_t>,
        )
      >();

  /// get current playing state
  ///
  /// \param o wavetable, created by new_aubio_wavetable()
  ///
  /// \return 0 if not playing, 1 if playing
  int aubio_wavetable_get_playing(ffi.Pointer<aubio_wavetable_t> o) {
    return _aubio_wavetable_get_playing(o);
  }

  late final _aubio_wavetable_get_playingPtr =
      _lookup<
        ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_wavetable_t>)>
      >('aubio_wavetable_get_playing');
  late final _aubio_wavetable_get_playing = _aubio_wavetable_get_playingPtr
      .asFunction<int Function(ffi.Pointer<aubio_wavetable_t>)>();

  /// set current playing state
  ///
  /// \param o wavetable, created by new_aubio_wavetable()
  /// \param playing 0 for not playing, 1 for playing
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_wavetable_set_playing(
    ffi.Pointer<aubio_wavetable_t> o,
    int playing,
  ) {
    return _aubio_wavetable_set_playing(o, playing);
  }

  late final _aubio_wavetable_set_playingPtr =
      _lookup<
        ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_wavetable_t>, uint_t)
        >
      >('aubio_wavetable_set_playing');
  late final _aubio_wavetable_set_playing = _aubio_wavetable_set_playingPtr
      .asFunction<int Function(ffi.Pointer<aubio_wavetable_t>, int)>();

  /// play sample from start
  ///
  /// \param o wavetable, created by new_aubio_wavetable()
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_wavetable_play(ffi.Pointer<aubio_wavetable_t> o) {
    return _aubio_wavetable_play(o);
  }

  late final _aubio_wavetable_playPtr =
      _lookup<
        ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_wavetable_t>)>
      >('aubio_wavetable_play');
  late final _aubio_wavetable_play = _aubio_wavetable_playPtr
      .asFunction<int Function(ffi.Pointer<aubio_wavetable_t>)>();

  /// stop wavetable
  ///
  /// \param o wavetable, created by new_aubio_wavetable()
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_wavetable_stop(ffi.Pointer<aubio_wavetable_t> o) {
    return _aubio_wavetable_stop(o);
  }

  late final _aubio_wavetable_stopPtr =
      _lookup<
        ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_wavetable_t>)>
      >('aubio_wavetable_stop');
  late final _aubio_wavetable_stop = _aubio_wavetable_stopPtr
      .asFunction<int Function(ffi.Pointer<aubio_wavetable_t>)>();

  /// set wavetable frequency
  ///
  /// \param o wavetable, created by new_aubio_wavetable()
  /// \param freq new frequency value for the wavetable
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_wavetable_set_freq(ffi.Pointer<aubio_wavetable_t> o, double freq) {
    return _aubio_wavetable_set_freq(o, freq);
  }

  late final _aubio_wavetable_set_freqPtr =
      _lookup<
        ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_wavetable_t>, smpl_t)
        >
      >('aubio_wavetable_set_freq');
  late final _aubio_wavetable_set_freq = _aubio_wavetable_set_freqPtr
      .asFunction<int Function(ffi.Pointer<aubio_wavetable_t>, double)>();

  /// get wavetable frequency
  ///
  /// \param o wavetable, created by new_aubio_wavetable()
  ///
  /// \return current frequency, in Hz
  double aubio_wavetable_get_freq(ffi.Pointer<aubio_wavetable_t> o) {
    return _aubio_wavetable_get_freq(o);
  }

  late final _aubio_wavetable_get_freqPtr =
      _lookup<
        ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_wavetable_t>)>
      >('aubio_wavetable_get_freq');
  late final _aubio_wavetable_get_freq = _aubio_wavetable_get_freqPtr
      .asFunction<double Function(ffi.Pointer<aubio_wavetable_t>)>();

  /// set wavetable amplitude
  ///
  /// \param o wavetable, created by new_aubio_wavetable()
  /// \param amp new amplitude value for the wavetable
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_wavetable_set_amp(ffi.Pointer<aubio_wavetable_t> o, double amp) {
    return _aubio_wavetable_set_amp(o, amp);
  }

  late final _aubio_wavetable_set_ampPtr =
      _lookup<
        ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_wavetable_t>, smpl_t)
        >
      >('aubio_wavetable_set_amp');
  late final _aubio_wavetable_set_amp = _aubio_wavetable_set_ampPtr
      .asFunction<int Function(ffi.Pointer<aubio_wavetable_t>, double)>();

  /// get wavetable amplitude
  ///
  /// \param o wavetable, created by new_aubio_wavetable()
  ///
  /// \return current amplitude
  double aubio_wavetable_get_amp(ffi.Pointer<aubio_wavetable_t> o) {
    return _aubio_wavetable_get_amp(o);
  }

  late final _aubio_wavetable_get_ampPtr =
      _lookup<
        ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_wavetable_t>)>
      >('aubio_wavetable_get_amp');
  late final _aubio_wavetable_get_amp = _aubio_wavetable_get_ampPtr
      .asFunction<double Function(ffi.Pointer<aubio_wavetable_t>)>();

  /// destroy aubio_wavetable_t object
  ///
  /// \param o wavetable, created by new_aubio_wavetable()
  void del_aubio_wavetable(ffi.Pointer<aubio_wavetable_t> o) {
    return _del_aubio_wavetable(o);
  }

  late final _del_aubio_wavetablePtr =
      _lookup<
        ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aubio_wavetable_t>)>
      >('del_aubio_wavetable');
  late final _del_aubio_wavetable = _del_aubio_wavetablePtr
      .asFunction<void Function(ffi.Pointer<aubio_wavetable_t>)>();

  /// create new parameter object
  ///
  /// \param min_value the minimum value of the new parameter
  /// \param max_value the maximum value of the new parameter
  /// \param steps the number of steps to interpolate from the old value to the target value
  ///
  /// \return the newly created ::aubio_parameter_t
  ffi.Pointer<aubio_parameter_t> new_aubio_parameter(
    double min_value,
    double max_value,
    int steps,
  ) {
    return _new_aubio_parameter(min_value, max_value, steps);
  }

  late final _new_aubio_parameterPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<aubio_parameter_t> Function(smpl_t, smpl_t, uint_t)
        >
      >('new_aubio_parameter');
  late final _new_aubio_parameter = _new_aubio_parameterPtr
      .asFunction<
        ffi.Pointer<aubio_parameter_t> Function(double, double, int)
      >();

  /// set target value of the parameter
  ///
  /// \param param parameter, created by ::new_aubio_parameter
  /// \param value new target value
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_parameter_set_target_value(
    ffi.Pointer<aubio_parameter_t> param,
    double value,
  ) {
    return _aubio_parameter_set_target_value(param, value);
  }

  late final _aubio_parameter_set_target_valuePtr =
      _lookup<
        ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_parameter_t>, smpl_t)
        >
      >('aubio_parameter_set_target_value');
  late final _aubio_parameter_set_target_value =
      _aubio_parameter_set_target_valuePtr
          .asFunction<int Function(ffi.Pointer<aubio_parameter_t>, double)>();

  /// get next parameter
  ///
  /// \param param parameter, created by ::new_aubio_parameter
  ///
  /// \return new interpolated parameter value
  double aubio_parameter_get_next_value(ffi.Pointer<aubio_parameter_t> param) {
    return _aubio_parameter_get_next_value(param);
  }

  late final _aubio_parameter_get_next_valuePtr =
      _lookup<
        ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_parameter_t>)>
      >('aubio_parameter_get_next_value');
  late final _aubio_parameter_get_next_value =
      _aubio_parameter_get_next_valuePtr
          .asFunction<double Function(ffi.Pointer<aubio_parameter_t>)>();

  /// get current parameter value, without interpolation
  ///
  /// \param param parameter, created by ::new_aubio_parameter
  ///
  /// \return current value
  double aubio_parameter_get_current_value(
    ffi.Pointer<aubio_parameter_t> param,
  ) {
    return _aubio_parameter_get_current_value(param);
  }

  late final _aubio_parameter_get_current_valuePtr =
      _lookup<
        ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_parameter_t>)>
      >('aubio_parameter_get_current_value');
  late final _aubio_parameter_get_current_value =
      _aubio_parameter_get_current_valuePtr
          .asFunction<double Function(ffi.Pointer<aubio_parameter_t>)>();

  /// set current parameter value, skipping interpolation
  ///
  /// \param param parameter, created by ::new_aubio_parameter
  /// \param value new parameter value
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_parameter_set_current_value(
    ffi.Pointer<aubio_parameter_t> param,
    double value,
  ) {
    return _aubio_parameter_set_current_value(param, value);
  }

  late final _aubio_parameter_set_current_valuePtr =
      _lookup<
        ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_parameter_t>, smpl_t)
        >
      >('aubio_parameter_set_current_value');
  late final _aubio_parameter_set_current_value =
      _aubio_parameter_set_current_valuePtr
          .asFunction<int Function(ffi.Pointer<aubio_parameter_t>, double)>();

  /// set number of steps used for interpolation
  ///
  /// \param param parameter, created by ::new_aubio_parameter
  /// \param steps new number of steps
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_parameter_set_steps(
    ffi.Pointer<aubio_parameter_t> param,
    int steps,
  ) {
    return _aubio_parameter_set_steps(param, steps);
  }

  late final _aubio_parameter_set_stepsPtr =
      _lookup<
        ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_parameter_t>, uint_t)
        >
      >('aubio_parameter_set_steps');
  late final _aubio_parameter_set_steps = _aubio_parameter_set_stepsPtr
      .asFunction<int Function(ffi.Pointer<aubio_parameter_t>, int)>();

  /// get number of steps of this parameter
  ///
  /// \param param parameter, created by ::new_aubio_parameter
  ///
  /// \return number of steps
  int aubio_parameter_get_steps(ffi.Pointer<aubio_parameter_t> param) {
    return _aubio_parameter_get_steps(param);
  }

  late final _aubio_parameter_get_stepsPtr =
      _lookup<
        ffi.NativeFunction<uint_t Function(ffi.Pointer<aubio_parameter_t>)>
      >('aubio_parameter_get_steps');
  late final _aubio_parameter_get_steps = _aubio_parameter_get_stepsPtr
      .asFunction<int Function(ffi.Pointer<aubio_parameter_t>)>();

  /// set minimum value of this parameter
  ///
  /// \param param parameter, created by ::new_aubio_parameter
  /// \param min_value new minimum value
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_parameter_set_min_value(
    ffi.Pointer<aubio_parameter_t> param,
    double min_value,
  ) {
    return _aubio_parameter_set_min_value(param, min_value);
  }

  late final _aubio_parameter_set_min_valuePtr =
      _lookup<
        ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_parameter_t>, smpl_t)
        >
      >('aubio_parameter_set_min_value');
  late final _aubio_parameter_set_min_value = _aubio_parameter_set_min_valuePtr
      .asFunction<int Function(ffi.Pointer<aubio_parameter_t>, double)>();

  /// get minimum value of this parameter
  ///
  /// \param param parameter, created by ::new_aubio_parameter
  ///
  /// \return minimum value
  double aubio_parameter_get_min_value(ffi.Pointer<aubio_parameter_t> param) {
    return _aubio_parameter_get_min_value(param);
  }

  late final _aubio_parameter_get_min_valuePtr =
      _lookup<
        ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_parameter_t>)>
      >('aubio_parameter_get_min_value');
  late final _aubio_parameter_get_min_value = _aubio_parameter_get_min_valuePtr
      .asFunction<double Function(ffi.Pointer<aubio_parameter_t>)>();

  /// set maximum value of this parameter
  ///
  /// \param param parameter, created by ::new_aubio_parameter
  /// \param max_value new maximum value
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_parameter_set_max_value(
    ffi.Pointer<aubio_parameter_t> param,
    double max_value,
  ) {
    return _aubio_parameter_set_max_value(param, max_value);
  }

  late final _aubio_parameter_set_max_valuePtr =
      _lookup<
        ffi.NativeFunction<
          uint_t Function(ffi.Pointer<aubio_parameter_t>, smpl_t)
        >
      >('aubio_parameter_set_max_value');
  late final _aubio_parameter_set_max_value = _aubio_parameter_set_max_valuePtr
      .asFunction<int Function(ffi.Pointer<aubio_parameter_t>, double)>();

  /// get maximum value of this parameter
  ///
  /// \param param parameter, created by ::new_aubio_parameter
  ///
  /// \return maximum value
  double aubio_parameter_get_max_value(ffi.Pointer<aubio_parameter_t> param) {
    return _aubio_parameter_get_max_value(param);
  }

  late final _aubio_parameter_get_max_valuePtr =
      _lookup<
        ffi.NativeFunction<smpl_t Function(ffi.Pointer<aubio_parameter_t>)>
      >('aubio_parameter_get_max_value');
  late final _aubio_parameter_get_max_value = _aubio_parameter_get_max_valuePtr
      .asFunction<double Function(ffi.Pointer<aubio_parameter_t>)>();

  /// destroy ::aubio_parameter_t object
  ///
  /// \param param parameter, created by ::new_aubio_parameter
  void del_aubio_parameter(ffi.Pointer<aubio_parameter_t> param) {
    return _del_aubio_parameter(param);
  }

  late final _del_aubio_parameterPtr =
      _lookup<
        ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aubio_parameter_t>)>
      >('del_aubio_parameter');
  late final _del_aubio_parameter = _del_aubio_parameterPtr
      .asFunction<void Function(ffi.Pointer<aubio_parameter_t>)>();

  /// Set logging function for all levels
  ///
  /// \param fun the function to be used to log, of type ::aubio_log_function_t
  /// \param data optional closure to be passed to the function (can be NULL if
  /// nothing to pass)
  void aubio_log_set_function(
    aubio_log_function_t fun,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _aubio_log_set_function(fun, data);
  }

  late final _aubio_log_set_functionPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(aubio_log_function_t, ffi.Pointer<ffi.Void>)
        >
      >('aubio_log_set_function');
  late final _aubio_log_set_function = _aubio_log_set_functionPtr
      .asFunction<void Function(aubio_log_function_t, ffi.Pointer<ffi.Void>)>();

  /// Set logging function for a given level
  ///
  /// \param level the level for which to set the logging function
  /// \param fun the function to be used to log, of type ::aubio_log_function_t
  /// \param data optional closure to be passed to the function (can be NULL if
  /// nothing to pass)
  aubio_log_function_t aubio_log_set_level_function(
    int level,
    aubio_log_function_t fun,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _aubio_log_set_level_function(level, fun, data);
  }

  late final _aubio_log_set_level_functionPtr =
      _lookup<
        ffi.NativeFunction<
          aubio_log_function_t Function(
            sint_t,
            aubio_log_function_t,
            ffi.Pointer<ffi.Void>,
          )
        >
      >('aubio_log_set_level_function');
  late final _aubio_log_set_level_function = _aubio_log_set_level_functionPtr
      .asFunction<
        aubio_log_function_t Function(
          int,
          aubio_log_function_t,
          ffi.Pointer<ffi.Void>,
        )
      >();

  /// Reset all logging functions to the default one
  ///
  /// After calling this function, the default logging function will be used to
  /// print error, warning, normal, and debug messages to `stdout` or `stderr`.
  void aubio_log_reset() {
    return _aubio_log_reset();
  }

  late final _aubio_log_resetPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('aubio_log_reset');
  late final _aubio_log_reset = _aubio_log_resetPtr
      .asFunction<void Function()>();
}

typedef smpl_t = ffi.Float;
typedef Dartsmpl_t = double;
typedef lsmp_t = ffi.Double;
typedef Dartlsmp_t = double;

/// unsigned integer
typedef uint_t = ffi.UnsignedInt;
typedef Dartuint_t = int;

/// signed integer
typedef sint_t = ffi.Int;
typedef Dartsint_t = int;

/// character
typedef char_t = ffi.Char;
typedef Dartchar_t = int;

/// Buffer for real data
///
/// Vector of real-valued data
///
/// ::fvec_t is is the structure used to store vector of real-valued data, ::smpl_t .
///
/// \code
///
/// uint_t buffer_size = 1024;
///
/// // create a vector of 512 values
/// fvec_t * input = new_fvec (buffer_size);
///
/// // set some values of the vector
/// input->data[23] = 2.;
/// // ..
///
/// // compute the mean of the vector
/// mean = fvec_mean(a_vector);
///
/// // destroy the vector
/// del_fvec(a_vector);
///
/// \endcode
///
/// See `examples/` and `tests/src` directories for more examples.
final class fvec_t extends ffi.Struct {
  /// < length of buffer
  @uint_t()
  external int length;

  /// < data vector of length ::fvec_t.length
  external ffi.Pointer<smpl_t> data;
}

/// Vector of real-valued phase and spectrum data
///
/// \code
///
/// uint_t buffer_size = 1024;
///
/// // create a complex vector of 512 values
/// cvec_t * input = new_cvec (buffer_size);
///
/// // set some values of the vector
/// input->norm[23] = 2.;
/// input->phas[23] = M_PI;
/// // ..
///
/// // compute the mean of the vector
/// mean = cvec_mean(input);
///
/// // destroy the vector
/// del_cvec (input);
///
/// \endcode
final class cvec_t extends ffi.Struct {
  /// < length of buffer = (requested length)/2 + 1
  @uint_t()
  external int length;

  /// < norm array of size ::cvec_t.length
  external ffi.Pointer<smpl_t> norm;

  /// < phase array of size ::cvec_t.length
  external ffi.Pointer<smpl_t> phas;
}

/// Buffer for real data in double precision
final class lvec_t extends ffi.Struct {
  /// < length of buffer
  @uint_t()
  external int length;

  /// < data array of size [length]
  external ffi.Pointer<lsmp_t> data;
}

/// Buffer for real data
final class fmat_t extends ffi.Struct {
  /// < length of matrix
  @uint_t()
  external int length;

  /// < height of matrix
  @uint_t()
  external int height;

  /// < data array of size [length] * [height]
  external ffi.Pointer<ffi.Pointer<smpl_t>> data;
}

final class _aubio_resampler_t extends ffi.Opaque {}

/// resampler object
typedef aubio_resampler_t = _aubio_resampler_t;

final class _aubio_filter_t extends ffi.Opaque {}

/// Digital filter
typedef aubio_filter_t = _aubio_filter_t;

final class _aubio_fft_t extends ffi.Opaque {}

/// FFT object
///
/// This object computes forward and backward FFTs.
typedef aubio_fft_t = _aubio_fft_t;

final class _aubio_dct_t extends ffi.Opaque {}

/// DCT object
///
/// This object computes forward and backward DCT type 2 with orthonormal
/// scaling.
typedef aubio_dct_t = _aubio_dct_t;

final class _aubio_pvoc_t extends ffi.Opaque {}

/// phasevocoder object
typedef aubio_pvoc_t = _aubio_pvoc_t;

final class _aubio_filterbank_t extends ffi.Opaque {}

/// filterbank object
///
/// This object stores a matrix of spectral filter coefficients.
typedef aubio_filterbank_t = _aubio_filterbank_t;

final class _aubio_mfcc_t extends ffi.Opaque {}

/// mfcc object
typedef aubio_mfcc_t = _aubio_mfcc_t;

final class _aubio_specdesc_t extends ffi.Opaque {}

/// spectral description structure
typedef aubio_specdesc_t = _aubio_specdesc_t;

final class _aubio_spectral_whitening_t extends ffi.Opaque {}

/// spectral whitening structure
typedef aubio_spectral_whitening_t = _aubio_spectral_whitening_t;

final class _aubio_tss_t extends ffi.Opaque {}

/// Transient / Steady-state Separation object
typedef aubio_tss_t = _aubio_tss_t;

final class _aubio_pitch_t extends ffi.Opaque {}

/// pitch detection object
typedef aubio_pitch_t = _aubio_pitch_t;

final class _aubio_onset_t extends ffi.Opaque {}

/// onset detection object
typedef aubio_onset_t = _aubio_onset_t;

final class _aubio_tempo_t extends ffi.Opaque {}

/// tempo detection structure
typedef aubio_tempo_t = _aubio_tempo_t;

final class _aubio_notes_t extends ffi.Opaque {}

/// notes detection object
typedef aubio_notes_t = _aubio_notes_t;

final class _aubio_source_t extends ffi.Opaque {}

/// media source object
typedef aubio_source_t = _aubio_source_t;

final class _aubio_sink_t extends ffi.Opaque {}

/// media sink object
typedef aubio_sink_t = _aubio_sink_t;

final class _aubio_sampler_t extends ffi.Opaque {}

/// sampler object
typedef aubio_sampler_t = _aubio_sampler_t;

final class _aubio_wavetable_t extends ffi.Opaque {}

/// wavetable object
typedef aubio_wavetable_t = _aubio_wavetable_t;

final class _aubio_parameter_t extends ffi.Opaque {}

/// parameter object
typedef aubio_parameter_t = _aubio_parameter_t;

/// list of logging levels
enum aubio_log_level {
  /// < critical errors
  AUBIO_LOG_ERR(0),

  /// < infos
  AUBIO_LOG_INF(1),

  /// < general messages
  AUBIO_LOG_MSG(2),

  /// < debug messages
  AUBIO_LOG_DBG(3),

  /// < warnings
  AUBIO_LOG_WRN(4),

  /// < number of valid levels
  AUBIO_LOG_LAST_LEVEL(5);

  final int value;
  const aubio_log_level(this.value);

  static aubio_log_level fromValue(int value) => switch (value) {
    0 => AUBIO_LOG_ERR,
    1 => AUBIO_LOG_INF,
    2 => AUBIO_LOG_MSG,
    3 => AUBIO_LOG_DBG,
    4 => AUBIO_LOG_WRN,
    5 => AUBIO_LOG_LAST_LEVEL,
    _ => throw ArgumentError('Unknown value for aubio_log_level: $value'),
  };
}

typedef aubio_log_function_tFunction =
    ffi.Void Function(
      sint_t level,
      ffi.Pointer<char_t> message,
      ffi.Pointer<ffi.Void> data,
    );
typedef Dartaubio_log_function_tFunction =
    void Function(
      Dartsint_t level,
      ffi.Pointer<char_t> message,
      ffi.Pointer<ffi.Void> data,
    );

/// Logging function prototype, to be passed to ::aubio_log_set_function
///
/// \param level log level
/// \param message text to log
/// \param data optional closure used by the callback
///
/// See @ref utils/test-log.c for an example of logging function.
typedef aubio_log_function_t =
    ffi.Pointer<ffi.NativeFunction<aubio_log_function_tFunction>>;

const int HAVE_AUBIO_DOUBLE = 0;

const String AUBIO_SMPL_FMT = '%f';

const String AUBIO_LSMP_FMT = '%lf';
